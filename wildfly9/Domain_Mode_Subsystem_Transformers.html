<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Domain Mode Subsystem Transformers - WildFly 9</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE8" />
    <meta content="Scroll Wiki Publisher" name="generator"/>

    <link type="text/css" rel="stylesheet" href="css/blueprint/liquid.css" media="screen, projection"/>
    <link type="text/css" rel="stylesheet" href="css/blueprint/print.css" media="print"/>
    <!--[if lt IE 8]><link rel="stylesheet" href="css/blueprint/ie.css" type="text/css" media="screen, projection"/><![endif]-->

    <link type="text/css" rel="stylesheet" href="css/content-style.css" media="screen, projection, print"/>
    <link type="text/css" rel="stylesheet" href="css/screen.css" media="screen, projection"/>
    <link type="text/css" rel="stylesheet" href="css/print.css" media="print"/>
    
    <link type="text/css" rel="stylesheet" href="css/jbossorg.css"/>
    <link type="text/css" rel="stylesheet" href="css/docnav.css"/>    
    
    <link type="text/css" rel="stylesheet" href="sh/shCore.css"/>
    <link type="text/css" rel="stylesheet" href="sh/shCoreDefault.css"/>
    <script type="text/javascript" src="sh/shCore.js"></script>
    <script type="text/javascript" src="sh/shBrushAppleScript.js"></script>
    <script type="text/javascript" src="sh/shBrushAS3.js"></script>
    <script type="text/javascript" src="sh/shBrushBash.js"></script>
    <script type="text/javascript" src="sh/shBrushCpp.js"></script>
    <script type="text/javascript" src="sh/shBrushCSharp.js"></script>
    <script type="text/javascript" src="sh/shBrushCss.js"></script>
    <script type="text/javascript" src="sh/shBrushDiff.js"></script>
    <script type="text/javascript" src="sh/shBrushErlang.js"></script>
    <script type="text/javascript" src="sh/shBrushGroovy.js"></script>
    <script type="text/javascript" src="sh/shBrushJava.js"></script>
    <script type="text/javascript" src="sh/shBrushJavaFX.js"></script>
    <script type="text/javascript" src="sh/shBrushJScript.js"></script>
    <script type="text/javascript" src="sh/shBrushPerl.js"></script>
    <script type="text/javascript" src="sh/shBrushPhp.js"></script>
    <script type="text/javascript" src="sh/shBrushPlain.js"></script>
    <script type="text/javascript" src="sh/shBrushPython.js"></script>
    <script type="text/javascript" src="sh/shBrushRuby.js"></script>
    <script type="text/javascript" src="sh/shBrushScala.js"></script>
    <script type="text/javascript" src="sh/shBrushSql.js"></script>
    <script type="text/javascript" src="sh/shBrushVb.js"></script>
    <script type="text/javascript" src="sh/shBrushXml.js"></script>
    
</head>
<body>
    <div class="container" style="min-width: 760px;">
        <div class="block header">
          <p id="title">
            <a class="site_href" href="http://www.jboss.org"><strong>JBoss.org</strong></a>
            <a class="doc_href" href="http://docs.jboss.org"><strong>Community Documentation</strong></a>
          </p>
                  <ul class="docnav">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <li class="previous"><a accesskey="p" href="Extending_WildFly.html"><strong>Prev</strong></a></li>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <li class="next"><a accesskey="n" href="Example_subsystem.html"><strong>Next</strong></a></li>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </ul>
                    <div>
            <h1>Domain Mode Subsystem Transformers</h1>
          </div>          
          </div>

        <div class="block content">
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-%22Abstract%22">&quot;Abstract&quot;</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Background">Background</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Gettingtheinitialdomainmodel">Getting the initial domain model</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Anoperationchangessomethinginthedomainconfiguration">An operation changes something in the domain configuration</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Versionsandbackwardcompatibility">Versions and backward compatibility</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Versioningofsubsystems">Versioning of subsystems</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Theroleoftransformers">The role of transformers</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Resourcetransformers">Resource transformers</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectioninresourcetransformers">Rejection in resource transformers</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Operationtransformers">Operation transformers</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectioninoperationtransformers">Rejection in operation transformers</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Differentprofilesfordifferentversions">Different profiles for different versions</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Ignoringresourcesonlegacyhosts">Ignoring resources on legacy hosts</a>    </p>
</li></ul></li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-HowdoIknowwhatneedstobetransformed%3F">How do I know what needs to be transformed?</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Gettingdataforapreviousversion">Getting data for a previous version</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Seewhatchanged">See what changed</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-HowdoIwriteatransformer%3F">How do I write a transformer?</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-ResourceTransformationDescriptionBuilder">ResourceTransformationDescriptionBuilder</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Silentlydiscardchildresources">Silently discard child resources</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectchildresource">Reject child resource</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Redirectaddressforchildresource">Redirect address for child resource</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Gettingachildresourcebuilder">Getting a child resource builder</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-AttributeTransformationDescriptionBuilder">AttributeTransformationDescriptionBuilder</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Attributetransformationlifecycle">Attribute transformation lifecycle</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Discardingattributes">Discarding attributes</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-TheDiscardAttributeCheckerinterface">The DiscardAttributeChecker interface</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-DiscardAttributeCheckerhelperclasses%2Fimplementations">DiscardAttributeChecker helper classes/implementations</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.DefaultDiscardAttribut...">DiscardAttributeChecker.DefaultDiscardAttributeChecker</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.DiscardAttributeValueC...">DiscardAttributeChecker.DiscardAttributeValueChecker</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.ALWAYS">DiscardAttributeChecker.ALWAYS</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.UNDEFINED">DiscardAttributeChecker.UNDEFINED</a>    </p>
</li></ul></li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectingattributes">Rejecting attributes</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-TheRejectAttributeCheckerinterface">The RejectAttributeChecker interface</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-RejectAttributeCheckerhelperclasses%2Fimplementations">RejectAttributeChecker helper classes/implementations</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.DefaultRejectAttributeC...">RejectAttributeChecker.DefaultRejectAttributeChecker</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.DEFINED">RejectAttributeChecker.DEFINED</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.SIMPLEEXPRESSIONS">RejectAttributeChecker.SIMPLE_EXPRESSIONS</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.ListRejectAttributeChecker">RejectAttributeChecker.ListRejectAttributeChecker</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.ObjectFieldsRejectAttri...">RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</a>    </p>
</li></ul></li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Convertingattributes">Converting attributes</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-TheAttributeConverterinterface">The AttributeConverter interface</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Introducingattributesduringtransformation">Introducing attributes during transformation</a>    </p>
</li></ul></li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Renamingattributes">Renaming attributes</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-OperationTransformationOverrideBuilder">OperationTransformationOverrideBuilder</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-EvolvingtransformerswithsubsystemModelVersions">Evolving transformers with subsystem ModelVersions</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Testingaconfigurationthatworks">Testing a configuration that works</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Testingaconfigurationthatdoesnotwork">Testing a configuration that does not work</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Commontransformationusecases">Common transformation use-cases</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Childresourcetypedoesnotexistinlegacymodel">Child resource type does not exist in legacy model</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Attributedoesnotexistinthelegacysubsystem">Attribute does not exist in the legacy subsystem</a>    </p>
<ul class=" "><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Defaultvalueoftheattributeisthesameaslegacyimpliedbehaviour">Default value of the attribute is the same as legacy implied behaviour</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Defaultvalueoftheattributeisdifferentfromlegacyimpliedbehaviour">Default value of the attribute is different from legacy implied behaviour</a>    </p>
</li></ul></li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Attributehasadifferentdefaultvalue">Attribute has a different default value</a>    </p>
</li><li class=" ">    <p>
<a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Attributehasadifferenttype">Attribute has a different type</a>    </p>
</li></ul></li></ul>    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-%22Abstract%22"  >
        <h2>&quot;Abstract&quot;</h2>
    
    <p>
A WildFly/JBoss AS 7 domain may consist of a new Domain Controller (DC) controlling slave Host Controllers (HC) running older versions. Each slave HC maintains a copy of the centralized domain configuration, which they use for controlling their own servers. In order for the slave HCs to understand the configuration from the DC, transformation is needed, whereby the DC translates the configuration and operations into something the slave HCs can understand.    </p>
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-Background"  >
        <h2>Background</h2>
    
    <p>
WildFly comes with a <a href="https://docs.jboss.org/author/display/WFLY8/Domain+Setup">domain mode</a> which allows you to have one Host Controller acting as the Domain Controller. The Domain Controller's job is to maintain the centralized domain configuration. Another term for the DC is 'Master Host Controller'. Before explaining why transformers are important and when they should be used, we will revisit how the domain configuration is used in domain mode.    </p>
    <p>
The centralized domain configuration is stored in <tt class=" ">domain.xml</tt>. This is only ever parsed on the DC, and it has the following structure:    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">extensions</tt> - contains:    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">extension</tt> - a references to a module that bootstraps the <tt class=" ">org.jboss.as.controller.Extension</tt> implementation used to bootstrap your subsystem parsers and initialize the resource definitions for your subsystems.    </p>
</li></ul></li><li class=" ">    <p>
<tt class=" ">profiles</tt> - contains:    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">profile</tt> - a named set of:    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">subsystem</tt> - contains the configuration for a subsystem, using the parser initialized by the subsystem's extension.    </p>
</li></ul></li></ul></li><li class=" ">    <p>
<tt class=" ">socket-binding-groups</tt> - contains:    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">socket-binding-group</tt> - a named set of:    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">socket-binding</tt> - A named port on an interface which can be referenced from the <tt class=" ">subsystem</tt> configurations for subsystems opening sockets.    </p>
</li></ul></li></ul></li><li class=" ">    <p>
<tt class=" ">server-groups</tt> - contains    </p>
<ul class=" "><li class=" ">    <p>
<tt class=" ">server-group</tt> - this has a name and references a <tt class=" ">profile</tt> and a <tt class=" ">socket-binding-group</tt>. The HCs then reference the <tt class=" ">server-group</tt> name from their <tt class=" ">&lt;servers&gt;</tt> section in <tt class=" ">host.xml</tt>.    </p>
</li></ul></li></ul>    <p>
When the DC parses <tt class=" ">domain.xml</tt>, it is transformed into <tt class=" ">add</tt> (and in some cases <tt class=" ">write-attribute</tt>) operations just as explained in <a href="https://docs.jboss.org/author/display/WFLY8/Parsing+and+marshalling+of+the+subsystem+xml">Parsing and marshalling of the subsystem xml</a>. These operations build up the model on the DC.    </p>
    <p>
A HC wishing to join the domain and use the DC's centralized configuration is known as a 'slave HC'. A slave HC maintains a copy of the DC's centralized domain configuration. This copy of the domain configuration is used to start its servers. This is done by asking the domain model to <tt class=" ">describe</tt> itself, which in turn asks the subsystems to <tt class=" ">describe</tt> themselves. The <tt class=" ">describe</tt> operation for a subsystem looks at the state of the subsystem model and produces the <tt class=" ">add</tt> operations necessary to create the subsystem on the server. The same mechanism also takes place on the DC (bear in mind that the DC is also a HC, which can have its own servers), although of course its copy of the domain configuration is the centralized one.    </p>
    <p>
There are two steps involved in keeping the keeping the slave HC's domain configuration in sync with the centralized domain configuration.    </p>
<ul class=" "><li class=" ">    <p>
getting the initial domain model    </p>
</li><li class=" ">    <p>
an operation changes something in the domain configuration    </p>
</li></ul>    <p>
Let's look a bit closer at what happens in each of these steps.    </p>
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Gettingtheinitialdomainmodel"  >
        <h3>Getting the initial domain model</h3>
    
    <p>
When a slave HC connects to the DC it obtains a copy of the domain model from the DC. This is done in a simpler serialized format, different from the operations that built up the model on the DC, or the operations resulting from the <tt class=" ">describe</tt> step used to bootstrap the servers. They describe each address that exists in the DC's model, and contain the attributes set for the resource at that address. This serialized form looks like this:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">[{
    &quot;domain-resource-address&quot; =&gt; [],
    &quot;domain-resource-model&quot; =&gt; {
        &quot;management-major-version&quot; =&gt; 2,
        &quot;management-minor-version&quot; =&gt; 0,
        &quot;management-micro-version&quot; =&gt; 0,
        &quot;release-version&quot; =&gt; &quot;8.0.0.Beta1-SNAPSHOT&quot;,
        &quot;release-codename&quot; =&gt; &quot;WildFly&quot;
    }
}, 
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;extension&quot; =&gt; &quot;org.jboss.as.clustering.infinispan&quot;)],
    &quot;domain-resource-model&quot; =&gt; {&quot;module&quot; =&gt; &quot;org.jboss.as.clustering.infinispan&quot;}
}, 
--SNIP - the rest of the extensions --
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;extension&quot; =&gt; &quot;org.jboss.as.weld&quot;)],
    &quot;domain-resource-model&quot; =&gt; {&quot;module&quot; =&gt; &quot;org.jboss.as.weld&quot;}
}, 
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;system-property&quot; =&gt; &quot;java.net.preferIPv4Stack&quot;)],
    &quot;domain-resource-model&quot; =&gt; {
        &quot;value&quot; =&gt; &quot;true&quot;,
        &quot;boot-time&quot; =&gt; undefined
    }
},
{
    &quot;domain-resource-address&quot; =&gt; [(&quot;profile&quot; =&gt; &quot;full-ha&quot;)],
    &quot;domain-resource-model&quot; =&gt; undefined
}, 
{
    &quot;domain-resource-address&quot; =&gt; [
        (&quot;profile&quot; =&gt; &quot;full-ha&quot;),
        (&quot;subsystem&quot; =&gt; &quot;logging&quot;)
    ],
    &quot;domain-resource-model&quot; =&gt; {}
}, 
{
    &quot;domain-resource-address&quot; =&gt; [sss|WFLY8:Example subsystem],
    &quot;domain-resource-model&quot; =&gt; {
        &quot;level&quot; =&gt; &quot;INFO&quot;,
        &quot;enabled&quot; =&gt; undefined,
        &quot;encoding&quot; =&gt; undefined,
        &quot;formatter&quot; =&gt; &quot;%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%E%n&quot;,
        &quot;filter-spec&quot; =&gt; undefined,
        &quot;autoflush&quot; =&gt; undefined,
        &quot;target&quot; =&gt; undefined,
        &quot;named-formatter&quot; =&gt; undefined
    }
}, 
--SNIP---</pre>
        </div>
    </div>
    <p>
The slave HC then applies these one at a time and builds up the initial domain model. It needs to do this before it can start any of its servers.    </p>
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Anoperationchangessomethinginthedomainconfiguration"  >
        <h3>An operation changes something in the domain configuration</h3>
    
    <p>
Once a domain is up and running we can still change things in the domain configuration. These changes must happen when connected to the DC, and are then propagated to the slave HCs, which then in turn propagate the changes to any servers running in a server group affected by the changes made. In this example:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">[disconnected /] connect 
[domain@localhost:9990 /] /profile=full/subsystem=datasources/data-source=ExampleDS:write-attribute(name=enabled,value=false)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; undefined,
    &quot;server-groups&quot; =&gt; {&quot;main-server-group&quot; =&gt; {&quot;host&quot; =&gt; {
        &quot;slave&quot; =&gt; {&quot;server-one&quot; =&gt; {&quot;response&quot; =&gt; {
            &quot;outcome&quot; =&gt; &quot;success&quot;,
            &quot;result&quot; =&gt; undefined,
            &quot;response-headers&quot; =&gt; {
                &quot;operation-requires-restart&quot; =&gt; true,
                &quot;process-state&quot; =&gt; &quot;restart-required&quot;
            }
        }}},
        &quot;master&quot; =&gt; {
            &quot;server-one&quot; =&gt; {&quot;response&quot; =&gt; {
                &quot;outcome&quot; =&gt; &quot;success&quot;,
                &quot;response-headers&quot; =&gt; {
                    &quot;operation-requires-restart&quot; =&gt; true,
                    &quot;process-state&quot; =&gt; &quot;restart-required&quot;
                }
            }},
            &quot;server-two&quot; =&gt; {&quot;response&quot; =&gt; {
                &quot;outcome&quot; =&gt; &quot;success&quot;,
                &quot;response-headers&quot; =&gt; {
                    &quot;operation-requires-restart&quot; =&gt; true,
                    &quot;process-state&quot; =&gt; &quot;restart-required&quot;
                }
            }}
        }
    }}}
}
</pre>
        </div>
    </div>
    <p>
the DC propagates the changes to itself <tt class=" ">host=master</tt>, which in turn propagates it to its two servers belonging to <tt class=" ">main-server-group</tt> which uses the <tt class=" ">full</tt> profile. More interestingly, it also propagates it to <tt class=" ">host=slave</tt> which updates its local copy of the domain model, and then propagates the change to its <tt class=" ">server-one</tt> which belongs to <tt class=" ">main-server-group</tt> which uses the <tt class=" ">full</tt> profile.    </p>
    </div>
    
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-Versionsandbackwardcompatibility"  >
        <h2>Versions and backward compatibility</h2>
    
    <p>
A HC and its servers will always be the same version of WildFly (they use the same module path and jars). However, the DC and the slave HCs do not necessarily need to be the same version. One of the points in the original specification for WildFly is that    </p>
    <div class="confbox admonition admonition-info">
            <div class="title">Important</div>
        
    <p>
A Doman Controller should be able to manage slave Host Controllers older than itself.    </p>
    </div>
    
    <p>
This means that for example a WildFly 8 DC should be able to work with slave HCs running JBoss AS 7.1.2. The opposite is not true, the DC must be the same or the newest version in the domain.    </p>
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Versioningofsubsystems"  >
        <h3>Versioning of subsystems</h3>
    
    <p>
To help with being able to know what is compatible we have versions within the subsystems, this is stored in the subsystem's extension. When registering the subsystem you will typically see something like:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public class SomeExtension implements Extension {

    private static final String SUBSYSTEM_NAME = &quot;my-subsystem&quot;'
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;

    /**
     * {@inheritDoc}
     * @see org.jboss.as.controller.Extension#initialize(org.jboss.as.controller.ExtensionContext)
     */
    @Override
    public void initialize(ExtensionContext context) {

        // IMPORTANT: Management API version != xsd version! Not all Management API changes result in XSD changes
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);

        //Register the resource definitions
        ....
    }
    ....
}</pre>
        </div>
    </div>
    <p>
Which sets the <tt class=" ">ModelVersion</tt> of the subsystem.    </p>
    <div class="confbox admonition admonition-info">
            <div class="title">Important</div>
        
    <p>
Whenever something changes in the subsystem, such as:    </p>
<ul class=" "><li class=" ">    <p>
an attribute is added or removed from a resource    </p>
</li><li class=" ">    <p>
a attribute is renamed in a resource    </p>
</li><li class=" ">    <p>
an attribute has its type changed    </p>
</li><li class=" ">    <p>
an attribute or operation parameter's nillable or allows expressions is changed    </p>
</li><li class=" ">    <p>
an attribute or operation parameter's default value changes    </p>
</li><li class=" ">    <p>
a child resource type is added or removed    </p>
</li><li class=" ">    <p>
an operation is added or removed    </p>
</li><li class=" ">    <p>
an operation has its parameters changed    </p>
</li></ul>    <p>
and the current version of the subsystem has been part of a Final release of WildFly, we <strong class=" ">must</strong> bump the version of the subsystem.    </p>
    </div>
    
    <p>
Once it has been increased you can of course make more changes until the next Final release without more version bumps. It is also worth noting that a new WildFly release does not automatically mean a new version for the subsystem, the new version is only needed if something was changed. For example the <tt class=" ">jaxrs</tt> subsystem has remained on 1.0.0 for all versions of WildFly and JBoss AS 7.    </p>
    <p>
You can find the <tt class=" ">ModelVersion</tt> of a subsystem by querying its extension:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">domain@localhost:9990 /] /extension=org.jboss.as.clustering.infinispan:read-resource(recursive=true)
{
    &quot;outcome&quot; =&gt; &quot;success&quot;,
    &quot;result&quot; =&gt; {
        &quot;module&quot; =&gt; &quot;org.jboss.as.clustering.infinispan&quot;,
        &quot;subsystem&quot; =&gt; {&quot;infinispan&quot; =&gt; {
            &quot;management-major-version&quot; =&gt; 2,
            &quot;management-micro-version&quot; =&gt; 0,
            &quot;management-minor-version&quot; =&gt; 0,
            &quot;xml-namespaces&quot; =&gt; [jboss:domain:infinispan:1.0&quot;,
                &quot;urn:jboss:domain:infinispan:1.1&quot;,
                &quot;urn:jboss:domain:infinispan:1.2&quot;,
                &quot;urn:jboss:domain:infinispan:1.3&quot;,
                &quot;urn:jboss:domain:infinispan:1.4&quot;,
                &quot;urn:jboss:domain:infinispan:2.0&quot;]
        }}
    }
}</pre>
        </div>
    </div>
    </div>
    
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-Theroleoftransformers"  >
        <h2>The role of transformers</h2>
    
    <p>
Now that we have mentioned the slave HCs registration process with the DC, and know about ModelVersions, it is time to mention that when registering with the DC, the slave HC will send across a list of all its subsystem ModelVersions. The DC maintains this information in a registry for each slave HC, so that it knows which transformers (if any) to invoke for a legacy slave. We will see how to write and register transformers later on in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-HowdoIwriteatransformer">How do I write a transformer</a>. Slave HCs from version 7.2.0 onwards will also include a list of resources that they ignore (see <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Ignoringresourcesonlegacyhosts">Ignoring resources on legacy hosts</a>), and the DC will maintain this information in its registry. The DC will not send across any resources that it knows a slave ignores during the initial domain model transfer. When forwarding operations onto the slave HCs, the DC will skip forwarding those to slave HCs ignoring those resources.    </p>
    <p>
There are two kinds of transformers:    </p>
<ul class=" "><li class=" ">    <p>
resource transformers    </p>
</li><li class=" ">    <p>
operation transformers    </p>
</li></ul>    <p>
The main function of transformers is to transform a subsystem to something that the legacy slave HC can understand, or to aggressively reject things that the legacy slave HC will not understand. Rejection, in this context, essentially means, that the resource or operation cannot safely be transformed to something valid on the slave, so the transformation fails. We will see later how to reject attributes in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectingattributes">Rejecting attributes</a>, and child resources in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectchildresource">Reject child resource</a>.    </p>
    <p>
Both resource and operation transformers are needed, but take effect at different times. Let us use the <tt class=" ">weld</tt> subsystem, which is relatively simple, as an example. In JBoss AS 7.2.0 and lower it had a ModelVersion of 1.0.0, and its resource description was as follows:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">                {
                    &quot;description&quot; =&gt; &quot;The configuration of the weld subsystem.&quot;,
                    &quot;attributes&quot; =&gt; {},
                    &quot;operations&quot; =&gt; {
                        &quot;remove&quot; =&gt; {
                            &quot;operation-name&quot; =&gt; &quot;remove&quot;,
                            &quot;description&quot; =&gt; &quot;Operation removing the weld subsystem.&quot;,
                            &quot;request-properties&quot; =&gt; {},
                            &quot;reply-properties&quot; =&gt; {}
                        },
                        &quot;add&quot; =&gt; {
                            &quot;operation-name&quot; =&gt; &quot;add&quot;,
                            &quot;description&quot; =&gt; &quot;Operation creating the weld subsystem.&quot;,
                            &quot;request-properties&quot; =&gt; {},
                            &quot;reply-properties&quot; =&gt; {}
                        }
                    },
                    &quot;children&quot; =&gt; {}
                },</pre>
        </div>
    </div>
    <p>
In WildFly 8, it has a ModelVersion of 2.0.0 and has added two attributes, <tt class=" ">require-bean-descriptor</tt> and <tt class=" ">non-portable</tt> mode:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">{
        &quot;description&quot; =&gt; &quot;The configuration of the weld subsystem.&quot;,
        &quot;attributes&quot; =&gt; {
            &quot;require-bean-descriptor&quot; =&gt; {
                &quot;type&quot; =&gt; BOOLEAN,
                &quot;description&quot; =&gt; &quot;If true then implicit bean archives without bean descriptor file (beans.xml) are ignored by Weld&quot;,
                &quot;expressions-allowed&quot; =&gt; true,
                &quot;nillable&quot; =&gt; true,
                &quot;default&quot; =&gt; false,
                &quot;access-type&quot; =&gt; &quot;read-write&quot;,
                &quot;storage&quot; =&gt; &quot;configuration&quot;,
                &quot;restart-required&quot; =&gt; &quot;no-services&quot;
            },
            &quot;non-portable-mode&quot; =&gt; {
                &quot;type&quot; =&gt; BOOLEAN,
                &quot;description&quot; =&gt; &quot;If true then the non-portable mode is enabled. The non-portable mode is suggested by the specification to overcome problems with legacy applications that do not use CDI SPI properly and may be rejected by more strict validation in CDI 1.1.&quot;,
                &quot;expressions-allowed&quot; =&gt; true,
                &quot;nillable&quot; =&gt; true,
                &quot;default&quot; =&gt; false,
                &quot;access-type&quot; =&gt; &quot;read-write&quot;,
                &quot;storage&quot; =&gt; &quot;configuration&quot;,
                &quot;restart-required&quot; =&gt; &quot;no-services&quot;
            }
        },
        &quot;operations&quot; =&gt; {
            &quot;remove&quot; =&gt; {
                &quot;operation-name&quot; =&gt; &quot;remove&quot;,
                &quot;description&quot; =&gt; &quot;Operation removing the weld subsystem.&quot;,
                &quot;request-properties&quot; =&gt; {},
                &quot;reply-properties&quot; =&gt; {}
            },
            &quot;add&quot; =&gt; {
                &quot;operation-name&quot; =&gt; &quot;add&quot;,
                &quot;description&quot; =&gt; &quot;Operation creating the weld subsystem.&quot;,
                &quot;request-properties&quot; =&gt; {
                    &quot;require-bean-descriptor&quot; =&gt; {
                        &quot;type&quot; =&gt; BOOLEAN,
                        &quot;description&quot; =&gt; &quot;If true then implicit bean archives without bean descriptor file (beans.xml) are ignored by Weld&quot;,
                        &quot;expressions-allowed&quot; =&gt; true,
                        &quot;required&quot; =&gt; false,
                        &quot;nillable&quot; =&gt; true,
                        &quot;default&quot; =&gt; false
                    },
                    &quot;non-portable-mode&quot; =&gt; {
                        &quot;type&quot; =&gt; BOOLEAN,
                        &quot;description&quot; =&gt; &quot;If true then the non-portable mode is enabled. The non-portable mode is suggested by the specification to overcome problems with legacy applications that do not use CDI SPI properly and may be rejected by more strict validation in CDI 1.1.&quot;,
                        &quot;expressions-allowed&quot; =&gt; true,
                        &quot;required&quot; =&gt; false,
                        &quot;nillable&quot; =&gt; true,
                        &quot;default&quot; =&gt; false
                    }
                },
                &quot;reply-properties&quot; =&gt; {}
            }
        },
        &quot;children&quot; =&gt; {}
    }</pre>
        </div>
    </div>
    <p>
In the rest of this section we will assume that we are running a DC running WildFly 8 so it will have ModelVersion 2.0.0 of the weld subsystem, and that we are running a slave using ModelVersion 1.0.0 of the weld subsystem.    </p>
    <div class="confbox admonition admonition-info">
            <div class="title">Important</div>
        
    <p>
Transformation always takes place on the Domain Controller, and is done when sending across the initial domain model AND forwarding on operations to legacy slave HCs.    </p>
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Resourcetransformers"  >
        <h3>Resource transformers</h3>
    
    <p>
When copying over the centralized domain configuration as mentioned in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Gettingtheinitialdomainmodel">Getting the initial domain model</a>, we need to make sure that the copy of the domain model is something that the servers running on the legacy slave HC understand. So if the centralized domain configuration had any of the two new attributes set, we would need to reject the transformation in the transformers. One reason for this is to keep things consistent, it doesn't look good if you connect to the slave HC and find attributes and/or child resources when doing <tt class=" ">:read-resource</tt> which are not there when you do <tt class=" ">:read-resource-description</tt>. Also, to make life easier for subsystem writers, most instances of the <tt class=" ">describe</tt> operation use a standard implementation which would include these attributes when creating the <tt class=" ">add</tt> operation for the server, which could cause problems there.    </p>
    <p>
Another, more concrete example from the logging subsystem is that it allows a '<tt class=" ">%K{...</tt>}' in the pattern formatter which makes the formatter use colour:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">            &lt;pattern-formatter pattern=&quot;%K{level}%d{HH:mm:ss,SSS} %-5p [%c] (%t) %s%E%n&quot;/&gt;</pre>
        </div>
    </div>
    <p>
This '<tt class=" ">%K{...</tt>}' however was introduced in JBoss AS &lt; 7.1.3 (ModelVersion 1.2.0), so if that makes it across to a slave HC running an older version, the servers <strong class=" ">will</strong> fail to start up. So the logging extension registers transformers to strip out the '<tt class=" ">%K{...</tt>}' from the attribute value (leaving '<tt class=" ">%-5p <div class=" error">    <p>
[%c]    </p>
</div> (%t) %s%E%n&quot;</tt>') so that the old slave HC's servers can understand it.    </p>
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Rejectioninresourcetransformers"  >
        <h4>Rejection in resource transformers</h4>
    
    <p>
Only slave HCs from JBoss AS 7.2.0 and newer inform the DC about their ignored resources (see <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Ignoringresourcesonlegacyhosts">Ignoring resources on legacy hosts</a>). This means that if a transformer on the DC rejects transformation for a legacy slave HC, exactly what happens to the slave HC depends on the version of the slave HC. If the slave HC is:    </p>
<ul class=" "><li class=" ">    <p>
<i class=" ">older than 7.2.0</i> - the DC has no means of knowing if the slave HC has ignored the resource being rejected or not. So we log a warning on the DC, and send over the serialized part of that model anyway. If the slave HC has ignored the resource in question, it does not apply it. If the slave HC has not ignored the resource in question, it will apply it, but no failure will happen until it tries to start a server which references this bad configuration.    </p>
</li><li class=" ">    <p>
<i class=" ">7.2.0 or newer</i> - If a resource is ignored on the slave HC, the DC knows about this, and will not attempt to transform or send the resource across to the slave HC. If the resource transformation is rejected, we know the resource was not ignored on the slave HC and so we can aggressively fail the transformation, which in turn will cause the slave HC to fail to start up.    </p>
</li></ul>    </div>
    
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Operationtransformers"  >
        <h3>Operation transformers</h3>
    
    <p>
When <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Anoperationchangessomethinginthedomainconfiguration">An operation changes something in the domain configuration</a> the operation gets sent across to the slave HCs to update their domain models. The slave HCs then forward this operation onto the affected servers. The same considerations as in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Resourcetransformers">Resource transformers</a> are true, although operation transformers give you quicker 'feedback' if something is not valid. If you try to execute:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">/profile=full/subsystem=weld:write-attribute(name=require-bean-descriptor, value=false)</pre>
        </div>
    </div>
    <p>
This will fail on the legacy slave HC since its version of the subsystem does not contain any such attribute. However, it is best to aggressively reject in such cases.    </p>
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Rejectioninoperationtransformers"  >
        <h4>Rejection in operation transformers</h4>
    
    <p>
For transformed operations we can always know if the operation is on an ignored resource in the legacy slave HC. In 7.2.0 onwards, we know this through the DC's registry of ignored resources on the slave. In older versions of slaves, we send the operation across to the slave, which tries to invoke the operation. If the operation is against an ignored resource we inform the DC about this fact. So as part of the transformation process, if something gets rejected we can (and do!) fail the transformation aggressively. If the operation invoked on the DC results in the operation being sent across to 10 slave HCs and one of them has a legacy version which ends up rejecting the transformation, we rollback the operation across the whole domain.    </p>
    </div>
    
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Differentprofilesfordifferentversions"  >
        <h3>Different profiles for different versions</h3>
    
    <p>
Now for the <tt class=" ">weld</tt> example we have been using there is a slight twist. We have the new <tt class=" ">require-bean-descriptor</tt> and <tt class=" ">non-portable-mode</tt> attributes. These have been added in WildFly 8 which supports Java EE 7, and thus CDI 1.1. JBoss AS 7.x supports Java EE 7, and thus CDI 1.0. In CDI 1.1 the values of these attributes are tweakable, so they can be set to either <tt class=" ">true</tt> or <tt class=" ">false</tt>. The default behaviour for these in CDI 1.1, if not set, is that they are <tt class=" ">false</tt>. However, for CDI 1.0 these were not tweakable, and with the way the subsystem in JBoss AS 7.x worked is similar to if they are set to <tt class=" ">true</tt>.    </p>
    <p>
The above discussion implies that to use the weld subsystem on a legacy slave HC, the <tt class=" ">domain.xml</tt> configuration for it must look like:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">&lt;subsystem xmlns=&quot;urn:jboss:domain:weld:2.0&quot; 
      require-bean-descriptor=&quot;true&quot; 
      non-portable-mode=&quot;true&quot;/&gt;</pre>
        </div>
    </div>
    <p>
We will see the exact mechanics for how this is actually done later but in short when pushing this to a legacy slave DC we register transformers which reject the transformation if these attributes are not set to <tt class=" ">true</tt> since that implies some behaviour not supported on the legacy slave DC. If they are <tt class=" ">true</tt>, all is well, and the transformers discard, or remove, these attributes since they don't exist in the legacy model. This removal is fine since they have the values which would result in the behaviour assumed on the legacy slave HC.    </p>
    <p>
That way the older slave HCs will work fine. However, we might also have WildFly 8 slave HCs in our domain, and they are missing out on the new features introduced by the attributes introduced in ModelVersion 2.0.0. If we do    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">&lt;subsystem xmlns=&quot;urn:jboss:domain:weld:2.0&quot; 
      require-bean-descriptor=&quot;false&quot; 
      non-portable-mode=&quot;false&quot;/&gt;</pre>
        </div>
    </div>
    <p>
then it will fail when doing transformation for the legacy controller. The solution is to put these in two different profiles in <tt class=" ">domain.xml</tt>    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">&lt;domain&gt;
....
  &lt;profiles&gt;
    &lt;profile name=&quot;full&quot;&gt;
      &lt;subsystem xmlns=&quot;urn:jboss:domain:weld:2.0&quot; 
        require-bean-descriptor=&quot;false&quot; 
        non-portable-mode=&quot;false&quot;/&gt;
      ...
    &lt;/profile&gt;
    &lt;profile name=&quot;full-legacy&quot;&gt;
      &lt;subsystem xmlns=&quot;urn:jboss:domain:weld:2.0&quot;
        require-bean-descriptor=&quot;true&quot; 
        non-portable-mode=&quot;true&quot;/&gt;
      ...
    &lt;/profile&gt;
  &lt;/profiles&gt;
  ...
  &lt;server-groups&gt;
    &lt;server-group name=&quot;main-server-group&quot; profile=&quot;full&quot;&gt;
      ....
    &lt;server-group&gt;
    &lt;server-group name=&quot;main-server-group-legacy&quot; profile=&quot;full-legacy&quot;&gt;
      ....
    &lt;server-group&gt;
  &lt;/server-groups&gt;
&lt;/domain&gt;</pre>
        </div>
    </div>
    <p>
Then have the HCs using WildFly 8 make their servers reference the <tt class=" ">main-server-group</tt> server group, and the HCs using older versions of WildFly 8 make their servers reference the <tt class=" ">main-server-group-legacy</tt> server group.    </p>
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Ignoringresourcesonlegacyhosts"  >
        <h4>Ignoring resources on legacy hosts</h4>
    
    <p>
Booting the above configuration will still cause problems on legacy slave HCs, especially if they are JBoss AS 7.2.0 or later. The reason for this is that when they register themselves with the DC it lets the DC know which <tt class=" ">ignored resources</tt> they have. If the DC comes to transform something it should reject for a slave HC and it is not part of its ignored resources it will aggressively fail the transformation. Versions of JBoss AS older than 7.2.0 still have this ignored resources mechanism, but don't let the DC know about what they have ignored so the DC cannot reject aggressively - instead it will log some warnings. However, it is still good practice to ignore resources you are not interested in regardless of which legacy version the slave HC is running.    </p>
    <p>
To ignore the profile we cannot understand we do the following in the legacy slave HC's <tt class=" ">host.xml</tt>    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">&lt;host xmlns=&quot;urn:jboss:domain:1.3&quot; name=&quot;slave&quot;&gt;
...
    &lt;domain-controller&gt;
       &lt;remote host=&quot;${jboss.test.host.master.address}&quot; port=&quot;${jboss.domain.master.port:9999}&quot; security-realm=&quot;ManagementRealm&quot;&gt;
            &lt;ignored-resources type=&quot;profile&quot;&gt;
                &lt;instance name=&quot;full-legacy&quot;/&gt;
            &lt;/ignored-resources&gt;
       &lt;/remote&gt;       
    &lt;/domain-controller&gt;
....
&lt;/host&gt;</pre>
        </div>
    </div>
    <div class="confbox admonition admonition-info">
            <div class="title">Important</div>
        
    <p>
Any top-level resource type can be ignored <tt class=" ">profile</tt>, <tt class=" ">extension</tt>, <tt class=" ">server=group</tt> etc. Ignoring a resource instance ignores that resource, and all its children.    </p>
    </div>
    
    </div>
    
    </div>
    
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-HowdoIknowwhatneedstobetransformed%3F"  >
        <h2>How do I know what needs to be transformed?</h2>
    
    <p>
There is a set of related classes in the <tt class=" ">org.jboss.as.controller.util</tt> package in <tt class=" ">controller/src/test/java</tt> to help you determine this. These are all runnable in your IDE, just start the WildFly or JBoss AS 7 instances as described below.    </p>
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Gettingdataforapreviousversion"  >
        <h3>Getting data for a previous version</h3>
    
    <p>
<tt class=" ">controller/src/test/resources/legacy-models</tt> contains the output for the previous WildFly/JBoss AS 7 versions, so check if the files for the version you want to check backwards compatibility are there yet. If not, then you need to do the following to get the subsystem definitions:    </p>
<ol class=" "><li class=" ">    <p>
Start the <strong class=" ">old</strong> version of WildFly/JBoss AS 7 using <tt class=" ">--server-config=standalone-full-ha.xml</tt>    </p>
</li><li class=" ">    <p>
Run <tt class=" ">org.jboss.as.controller.util.GrabModelVersionsUtil</tt>, which will output the subsystem versions to <tt class=" ">controller/target/standalone-model-versions-running.dmr</tt>    </p>
</li><li class=" ">    <p>
Run <tt class=" ">org.jboss.as.controller.util.</tt> which will output the full resource definition to <tt class=" ">controller/target/standalone-resource-definition-running.dmr</tt>    </p>
</li><li class=" ">    <p>
Stop the running version of WildFly/JBoss AS 7    </p>
</li></ol>    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Seewhatchanged"  >
        <h3>See what changed</h3>
    
    <p>
To do this follow the following steps    </p>
<ol class=" "><li class=" ">    <p>
Start the <strong class=" ">new</strong> version of WildFly using <tt class=" ">--server-config=standalone-full-ha.xml</tt>    </p>
</li><li class=" ">    <p>
Run <tt class=" ">org.jboss.as.controller.util.CompareModelVersionsUtil</tt> and answer the following questions&quot;    </p>
<ol class=" "><li class=" ">    <p>
Enter Legacy AS version:    </p>
<ul class=" "><li class=" ">    <p>
If it is known version in the <tt class=" ">controller/src/test/resources/legacy-models</tt> folder, enter the version number.    </p>
</li><li class=" ">    <p>
If it is a not known version, and you got the data yourself in the last step, enter '<tt class=" ">running</tt>'    </p>
</li></ul></li><li class=" ">    <p>
Enter type:    </p>
<ul class=" "><li class=" ">    <p>
Answer '<tt class=" ">S</tt>'    </p>
</li></ul></li><li class=" ">    <p>
Read from target directory or from the legacy-models directory:    </p>
<ul class=" "><li class=" ">    <p>
If it is known version in the <tt class=" ">controller/src/test/resources/legacy-models</tt> folder, enter '<tt class=" ">l</tt>'.    </p>
</li><li class=" ">    <p>
If it is a not known version, and you got the data yourself in the last step, enter '<tt class=" ">t</tt>'    </p>
</li></ul></li><li class=" ">    <p>
Report on differences in the model when the management versions are different?:    </p>
<ul class=" "><li class=" ">    <p>
Answer '<tt class=" ">y</tt>'    </p>
</li></ul></li></ol></li></ol>    <p>
Here is some example output, as a subsystem developer you can ignore everything down to <tt class=" ">====== Comparing subsystem models ======</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">Enter legacy AS version: 7.2.0.Final
Using target model: 7.2.0.Final
Enter type [S](standalone)/H(host)/D(domain)/F(domain + host):S
Read from target directory or from the legacy-models directory - t/[l]:
Report on differences in the model when the management versions are different? y/[n]: y
Reporting on differences in the model when the management versions are different
Loading legacy model versions for 7.2.0.Final....
Loaded legacy model versions
Loading model versions for currently running server...
Oct 01, 2013 6:26:03 PM org.xnio.Xnio &lt;clinit&gt;
INFO: XNIO version 3.1.0.CR7
Oct 01, 2013 6:26:03 PM org.xnio.nio.NioXnio &lt;clinit&gt;
INFO: XNIO NIO Implementation Version 3.1.0.CR7
Oct 01, 2013 6:26:03 PM org.jboss.remoting3.EndpointImpl &lt;clinit&gt;
INFO: JBoss Remoting version 4.0.0.Beta1
Loaded current model versions
Loading legacy resource descriptions for 7.2.0.Final....
Loaded legacy resource descriptions
Loading resource descriptions for currently running STANDALONE...
Loaded current resource descriptions
Starting comparison of the current....

====== Comparing core models ======
-- SNIP --

====== Comparing subsystem models ======
-- SNIP --
====== Resource root address: [&quot;subsystem&quot; =&gt; &quot;remoting&quot;] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
Missing child types in current: []; missing in legacy [http-connector]
--- Problems for relative address to root [&quot;remote-outbound-connection&quot; =&gt; &quot;*&quot;]:
Missing attributes in current: []; missing in legacy [protocol]
Missing parameters for operation 'add' in current: []; missing in legacy [protocol]
-- SNIP -- 
====== Resource root address: [&quot;subsystem&quot; =&gt; &quot;weld&quot;] - Current version: 2.0.0; legacy version: 1.0.0 =======
--- Problems for relative address to root []:
Missing attributes in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
Missing parameters for operation 'add' in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]

Done comparison of STANDALONE!</pre>
        </div>
    </div>
    <p>
So we can see that for the <tt class=" ">remoting</tt> subsystem, we have added a child type called <tt class=" ">http-connector</tt>, and we have added an attribute called <tt class=" ">protocol</tt> (they are missing in legacy).<br/>in the <tt class=" ">weld</tt> subsystem, we have added the <tt class=" ">require-bean-descriptor</tt> and <tt class=" ">non-portable-mode</tt> attributes in the current version. It will also point out other issues like changed attribute types, changed defaults etc.    </p>
    <div class="confbox admonition admonition-warning">
            <div class="title">Warning</div>
        
    <p>
Note that CompareModelVersionsUtil simply inspects the raw resource descriptions of the specified legacy and current models. Its results show the differences between the two. They do not take into account whether one or more transformers have already been written for those versions differences. You will need to check that transformers are not already in place for those versions.    </p>
    </div>
    
    <p>
One final point to consider are that some subsystems register runtime-only resources and operations. For example the <tt class=" ">modcluster</tt> subsystem has a <tt class=" ">stop</tt> method. These do not get registered on the <tt class=" ">DC</tt>, e.g. there is no <tt class=" ">/profile=full-ha/subsystem=modcluster:stop</tt> operation, it only exists on the servers, for example <tt class=" ">/host=xxx/server=server-one/subsystem=modcluster:stop</tt>. What this means is that you don't have to transform such operations and resources. The reason is they are not callable on the DC, and so do not need propagation to the servers in the domain, which in turn means no transformation is needed.    </p>
    </div>
    
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-HowdoIwriteatransformer%3F"  >
        <h2>How do I write a transformer?</h2>
    
    <p>
There are two APIs available to write transformers for a resource. There is the original low-level API where you register transformers directly, the general idea is that you get hold of a <tt class=" ">TransformersSubRegistration</tt> for each level and implement the <tt class=" ">ResourceTransformer</tt>, <tt class=" ">OperationTransformer</tt> and <tt class=" ">PathAddressTransformer</tt> interfaces directly. It is, however, a pretty complex thing to do, so we recommend the other approach. For completeness here is the entry point to handling transformation in this way.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public class SomeExtension implements Extension {

    private static final String SUBSYSTEM_NAME = &quot;my-subsystem&quot;'
 
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;

    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }

    static void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_1_0(subsystem);
        registerTransformers_1_2_0(subsystem);
    }

    /**
     * Registers transformers from the current version to ModelVersion 1.1.0
     */
    private static void registerTransformers_1_1_0(final SubsystemRegistration subsystem) {
        final ModelVersion version = ModelVersion.create(1, 1, 0);

        //The default resource transformer forwards all operations
        final TransformersSubRegistration registration = subsystem.registerModelTransformers(version, ResourceTransformer.DEFAULT);
        final TransformersSubRegistration child = registration.registerSubResource(PathElement.pathElement(&quot;child&quot;));
        //We can do more things on the TransformersSubRegistation instances


        registerRelayTransformers(stack);
    }</pre>
        </div>
    </div>
    <p>
Having implemented a number of transformers using the above approach, we decided to simplify things, so we introduced the <tt class=" ">org.jboss.as.controller.transform.description.ResourceTransformationDescriptionBuilder</tt> API. It is a lot simpler and avoids a lot of the duplication of functionality required by the low-level API approach. While it doesn't give you the full power that the low-level API does, we found that there are very few places in the WildFly codebase where this does not work, so we will focus on the <tt class=" ">ResourceTransformationDescriptionBuilder</tt> API here. (If you come across a problem where this does not work, get in touch with someone from the WildFly Domain Management Team and we should be able to help). The builder API makes all the nasty calls to <tt class=" ">TransformersSubRegistration</tt> for you under the hood. It also allows you to fall back to the low-level API in places, although that will not be covered in the current version of this guide. The entry point for using the builder API here is taken from the WeldExtension (in current WildFly this has ModelVersion 2.0.0).    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private void registerTransformers(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        //These new attributes are assumed to be 'true' in the old version but default to false in the current version. So discard if 'true' and reject if 'undefined'.
        builder.getAttributeBuilder()
                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, false, new ModelNode(true)),
                        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .addRejectCheck(new RejectAttributeChecker.DefaultRejectAttributeChecker() {

                    @Override
                    public String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes) {
                        return WeldMessages.MESSAGES.rejectAttributesMustBeTrue(attributes.keySet());
                    }

                    @Override
                    protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue,
                            TransformationContext context) {
                        //This will not get called if it was discarded, so reject if it is undefined (default==false) or if defined and != 'true'
                        return !attributeValue.isDefined() || !attributeValue.asString().equals(&quot;true&quot;);
                    }
                }, WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }</pre>
        </div>
    </div>
    <p>
Here we register a <tt class=" ">discard check</tt> and a <tt class=" ">reject check</tt>. As mentioned in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Attributetransformationlifecycle">Attribute transformation lifecycle</a> all attributes are inspected for whether they should be discarded first. Then all attributes which were not discarded are checked for if they should be rejected. We will dig more into what this code means in the next few sections, but in short it means that we discard the <tt class=" ">require-bean-descriptor</tt> and <tt class=" ">non-portable</tt> attributes on the <tt class=" ">weld</tt> subsystem resource if they have the value <tt class=" ">true</tt>. If they have any other value, they will not get discarded and so reach the reject check, which will reject the transformation of the attributes if they have any other value.    </p>
    <p>
Here we are saying that we should discard the <tt class=" ">require-bean-descriptor</tt> and <tt class=" ">non-portable-mode</tt> attributes on the <tt class=" ">weld</tt> subsystem resource if they are undefined, and reject them if they are defined. So that means that if the weld subsystem looks like    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    {
        &quot;non-portable-mode&quot; =&gt; false,
        &quot;require-bean-descriptor&quot; =&gt; false
    }</pre>
        </div>
    </div>
    <p>
or    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    {
        &quot;non-portable-mode&quot; =&gt; undefined,
        &quot;require-bean-descriptor&quot; =&gt; undefined
    }</pre>
        </div>
    </div>
    <p>
or any other combination (the default values for these attributes if undefined is <tt class=" ">false</tt>) we will reject the transformation for the slave legacy HC.    </p>
    <p>
If the resource has true for these attributes:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    {
        &quot;non-portable-mode&quot; =&gt; true,
        &quot;require-bean-descriptor&quot; =&gt; true
    }</pre>
        </div>
    </div>
    <p>
they both get discarded (i.e. removed), so they will not get inspected for rejection, and an empty model not containing these attributes gets sent to the legacy HC.    </p>
    <p>
Here we will discuss this API a bit more, to outline the most important features/most commonly needed tasks.    </p>
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-ResourceTransformationDescriptionBuilder"  >
        <h3>ResourceTransformationDescriptionBuilder</h3>
    
    <p>
The <tt class=" ">ResourceTransformationDescriptionBuilder</tt> contains transformations for a resource type. The initial one is for the subsystem, obtained by the following call:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">        ResourceTransformationDescriptionBuilder subsystemBuilder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();</pre>
        </div>
    </div>
    <p>
The <tt class=" ">ResourceTransformationDescriptionBuilder</tt> contains functionality for how to handle child resources, which we will look at in this section. It is also the entry point to how to handle  transformation of attributes as we will see in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-AttributeTransformationDescriptionBuilder">AttributeTransformationDescriptionBuilder</a>. Also, it allows you to further override operation transformation as discussed in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-OperationTransformationOverrideBuilder">OperationTransformationOverrideBuilder</a>. When we have finished with our builder, we register it with the <tt class=" ">SubsystemRegistration</tt> against the target ModelVersion.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">        TransformationDescription.Tools.register(subsystemBuilder.build(), subsystem, ModelVersion.create(1, 0, 0));</pre>
        </div>
    </div>
    <div class="confbox admonition admonition-info">
            <div class="title">Important</div>
        
    <p>
If you have several old ModelVersions you could be transforming to, you need a separate builder for each of those.    </p>
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Silentlydiscardchildresources"  >
        <h4>Silently discard child resources</h4>
    
    <p>
To make the <tt class=" ">ResourceTransformationDescriptionBuilder</tt> do something, we need to call some of its methods. For example, if we want to silently discard a child resource, we can do    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    subsystemBuilder.discardChildResource(PathElement.pathElement(&quot;child&quot;, &quot;discarded&quot;));</pre>
        </div>
    </div>
    <p>
This means that any usage of <tt class=" ">/subsystem=my-subsystem/child=discarded</tt> never make it to the legacy slave HC running ModelVersion 1.0.0. During the initial domain model transfer, that part of the serialized domain model is stripped out, and any operations on this address are not forwarded on to the legacy slave HCs running that version of the subsystem. (For brevity this section will leave out the leading <tt class=" ">/profile=xxx</tt> part used in domain mode, and use <tt class=" ">/subsystem=my-subsystem</tt> as the 'top-level' address).    </p>
    <div class="confbox admonition admonition-warning">
            <div class="title">Warning</div>
        
    <p>
Note that discarding, although the simplest option in theory, is <strong class=" ">rarely the right thing to do</strong>.    </p>
    </div>
    
    <p>
The presence of the defined child normally implies some behaviour on the DC, and that behaviour is not available on the legacy slave HC, so normally rejection is a better policy for those cases. Remember we can have different profiles targeting different groups of versions of legacy slave HCs.    </p>
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Rejectchildresource"  >
        <h4>Reject child resource</h4>
    
    <p>
If we want to reject transformation if a child resource exists, we can do    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    subsystemBuilder.rejectChildResource(PathElement.pathElement(&quot;child&quot;, &quot;reject&quot;));</pre>
        </div>
    </div>
    <p>
Now, if there are any legacy slaves running ModelVersion 1.0.0, any usage of <tt class=" ">/subsystem=my-subsystem/child=reject</tt> will get rejected for those slaves. Both during the initial domain model transfer, and if any operations are invoked on that address. For example the <tt class=" ">remoting</tt> subsystem did not have a <tt class=" ">http-connector=*</tt> child until ModelVersion 2.0.0, so it is set up to reject that child when transforming to legacy HCs for all previous ModelVersions (1.1.0, 1.2.0 and 1.3.0). (See <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectioninresourcetransformers">Rejection in resource transformers</a> and <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectioninoperationtransformers">Rejection in operation transformers</a> for exactly what happens when something is rejected).    </p>
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Redirectaddressforchildresource"  >
        <h4>Redirect address for child resource</h4>
    
    <p>
Sometimes we rename the addresses for a child resource between model versions. To do that we use one of the <tt class=" ">addChildRedirection()</tt> methods, note that these also return a builder for the child resource (since we are not rejecting or discarding it), we can do this for all children of a given type:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    ResourceTransformationDescriptionBuilder childBuilder = 
       subsystemBuilder.addChildRedirection(PathElement.pathElement(&quot;newChild&quot;), PathElement.pathElement(&quot;oldChild&quot;);</pre>
        </div>
    </div>
    <p>
Now, in the initial domain transfer <tt class=" ">/subsystem=my-subsystem/newChild=test</tt> becomes <tt class=" ">/subsystem=my-subsystem/oldChild=test</tt>. Similarly all operations against the former address get mapped to the latter when executing operations on the DC before sending them to the legacy slave HC running ModelVersion 1.1.0 of the subsystem.    </p>
    <p>
We can also rename a specific named child:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    ResourceTransformationDescriptionBuilder childBuilder = 
       subsystemBuilder.addChildRedirection(PathElement.pathElement(&quot;newChild&quot;, &quot;newName&quot;), PathElement.pathElement(&quot;oldChild&quot;, &quot;oldName&quot;);</pre>
        </div>
    </div>
    <p>
Now, <tt class=" ">/subsystem=my-subsystem/newChild=newName</tt> becomes <tt class=" ">/subsystem=my-subsystem/oldChild=oldName</tt> both in the initial domain transfer, and when mapping operations to the legacy slave. For example, under the <tt class=" ">web</tt> subsystem <tt class=" ">ssl=configuration</tt> got renamed to <tt class=" ">configuration=ssl</tt> in later versions, meaning we need a redirect from <tt class=" ">configuration=ssl</tt> to <tt class=" ">ssl=configuration</tt> in its transformers.    </p>
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Gettingachildresourcebuilder"  >
        <h4>Getting a child resource builder</h4>
    
    <p>
Sometimes we don't want to transform the subsystem resource, but we want to transform something in one of its child resources. Again, since we are not discarding or rejecting, we get a reference to the builder for the child resource.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    ResourceTransformationDescriptionBuilder childBuilder = 
       subsystemBuilder.addChildResource(PathElement.pathElement(&quot;some-child&quot;));
    //We don't actually want to transform anything in /subsystem-my-subsystem/some-child=* either :-)
    //We are interested in /subsystem-my-subsystem/some-child=*/another-level
    ResourceTransformationDescriptionBuilder anotherBuilder = 
       childBuilder.addChildResource(PathElement.pathElement(&quot;another-level&quot;));

    //Use anotherBuilder to add child-resource and/or attribute transformation
    ....</pre>
        </div>
    </div>
    </div>
    
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-AttributeTransformationDescriptionBuilder"  >
        <h3>AttributeTransformationDescriptionBuilder</h3>
    
    <p>
To transform attributes you call <tt class=" ">ResourceTransformationDescriptionBuilder.getAttributeBuilder()</tt> which returns you a <tt class=" ">AttributeTransformationDescriptionBuilder</tt> which is used to define transformation for the resource's attributes. For example this gets the attribute builder for the subsystem resource:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    AttributeTransformationDescriptionBuilder attributeBuilder = subSystemBuilder.getAttributeBuilder();</pre>
        </div>
    </div>
    <p>
or we could get it for one of the child resources:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    ResourceTransformationDescriptionBuilder childBuilder = 
       subsystemBuilder.addChildResource(PathElement.pathElement(&quot;some-child&quot;));
    AttributeTransformationDescriptionBuilder attributeBuilder = childBuilder.getAttributeBuilder();</pre>
        </div>
    </div>
    <p>
The attribute transformations defined by the <tt class=" ">AttributeTransformationDescriptionBuilder</tt> will also impact the parameters to all operations defined on the resource. This means that if you have defined the <tt class=" ">example</tt> attribute of <tt class=" ">/subsystem=my-subsystem/some-child=*</tt> to reject transformation if its value is <tt class=" ">true</tt>, the inital domain transfer will reject if it is <tt class=" ">true</tt>, also the transformation of the following operations will reject:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /subsystem=my-subsystem/some-child=test:add(example=true)
    /subsystem=my-subsystem:write-attribute(name=example, value=true)
    /subsystem=my-subsystem:custom-operation(example=true)</pre>
        </div>
    </div>
    <p>
The following operations will pass in this example, since the <tt class=" ">example</tt> attribute is not getting set to <tt class=" ">true</tt>    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /subsystem=my-subsystem/some-child=test:add(example=false)
    /subsystem=my-subsystem/some-child=test:add()             //Here it 'example' is simply left undefined
    /subsystem=my-subsystem:write-attribute(name=example, value=false)
    /subsystem=my-subsystem:undefine-attribute(name=example)  //Again this makes 'example' undefined
    /subsystem=my-subsystem:custom-operation(example=false)</pre>
        </div>
    </div>
    <p>
For the rest of the examples in this section we assume that the <tt class=" ">attributeBuilder</tt> is for <tt class=" ">/subsystem=my-subsystem</tt>    </p>
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Attributetransformationlifecycle"  >
        <h4>Attribute transformation lifecycle</h4>
    
    <p>
There is a well defined lifecycle used for attribute transformation that is worth explaining before jumping into specifics. Transformation is done in the following phases, in the following order:    </p>
<ol class=" "><li class=" ">    <p>
<tt class=" ">discard</tt> - All attributes in the domain model transfer or invoked operation that have been registered for a discard check, are checked to see if the attribute should be discarded. If an attribute should be discarded, it is removed from the resource's attributes/operation's parameters and it does not get passed to the next phases. Once discarded it does not get sent to the legacy slave HC.    </p>
</li><li class=" ">    <p>
<tt class=" ">reject</tt> - All attributes that have been registered for a reject check (and which not have been discarded) are checked to see if the attribute should be rejected. As explained in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectioninresourcetransformers">Rejection in resource transformers</a> and <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectioninoperationtransformers">Rejection in operation transformers</a> exactly what happens when something is rejected varies depending on whether we are transforming a resource or an operation, and the version of the legacy slave HC we are transforming for. If a transformer rejects an attribute, all other reject transformers still get invoked, and the next phases also get invoked. This is because we don't know in all cases what will happen if a reject happens. Although this might sound cumbersome, in practice it actually makes it easier to write transformers since you only need one kind regardless of if it is a resource, an operation, and legacy slave HC version. However, as we will see in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Commontransformationusecases">Common transformation use-cases</a>, it means some extra checks are needed when writing reject and convert transformers.    </p>
</li><li class=" ">    <p>
<tt class=" ">convert</tt> - All attributes that have been registered for conversion are checked to see if the attribute should be converted. If the attribute does not exist in the original operation/resource it may be introduced. This is useful for setting default values for the target legacy slave HC.    </p>
</li><li class=" ">    <p>
<tt class=" ">rename</tt> - All attributes registered for renaming are renamed.    </p>
</li></ol>    <p>
Next, let us have a look at how to register attributes for each of these phases.    </p>
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Discardingattributes"  >
        <h4>Discarding attributes</h4>
    
    <p>
The general idea behind a discard is that we remove attributes which do not exist in the legacy slave HC's model. However, as hopefully described below, we normally can't simply discard everything, we need to check the values first.    </p>
    <p>
To discard an attribute we need an instance of <tt class=" ">org.jboss.as.controller.transform.description.DiscardAttributeChecker</tt>, and call the following method on the <tt class=" ">AttributeTransformationDescriptionBuilder</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     DiscardAttributeChecker discardCheckerA = ....;
     attributeBuilder.setDiscard(discardCheckerA, &quot;attr1&quot;, &quot;attr2&quot;);</pre>
        </div>
    </div>
    <p>
As shown, you can register the <tt class=" ">DiscardAttributeChecker</tt> for several attributes at once, in the above example both <tt class=" ">attr1</tt> and <tt class=" ">attr2</tt> get checked for if they should be discarded. You can also register different <tt class=" ">DiscardAttributeChecker</tt> instances for different attributes:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     DiscardAttributeChecker discardCheckerA = ....;
     DiscardAttributeChecker discardCheckerB = ....;
     attributeBuilder.setDiscard(discardCheckerA, &quot;attr1&quot;);
     attributeBuilder.setDiscard(discardCheckerA, &quot;attr2&quot;);</pre>
        </div>
    </div>
    <p>
Note that you can only have one <tt class=" ">DiscardAttributeChecker</tt> per attribute, so the following would cause an error (if running with assertions enabled, otherwise <tt class=" ">discardCheckerB</tt> will overwrite <tt class=" ">discardCheckerA</tt>):    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     DiscardAttributeChecker discardCheckerA = ....;
     DiscardAttributeChecker discardCheckerB = ....;
     attributeBuilder.setDiscard(discardCheckerA, &quot;attr1&quot;);
     attributeBuilder.setDiscard(discardCheckerB, &quot;attr1&quot;);</pre>
        </div>
    </div>
    <div class="section-5"  id="80873455_DomainModeSubsystemTransformers-TheDiscardAttributeCheckerinterface"  >
        <h5>The DiscardAttributeChecker interface</h5>
    
    <p>
<tt class=" ">org.jboss.as.controller.transform.description.DiscardAttributeChecker</tt> contains both the <tt class=" ">DiscardAttributeChecker</tt> and some helper implementations. The implementations of this interface get called for each attribute they are registered against. The interface itself is quite simple:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public interface DiscardAttributeChecker {

    /**
     * Returns {@code true} if the attribute should be discarded if expressions are used
     *
     * @return whether to discard if expressions are used
     */
    boolean isDiscardExpressions();</pre>
        </div>
    </div>
    <p>
Return <tt class=" ">true</tt> here to discard the attribute if it is an expression. If it is an expression, and this method returns <tt class=" ">true</tt>, the <tt class=" ">isOperationParameterDiscardable</tt> and <tt class=" ">isResourceAttributeDiscardable</tt> methods will not get called.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Returns {@code true} if the attribute should be discarded if it is undefined
     *
     * @return whether to discard if the attribute is undefined
     */
    boolean isDiscardUndefined();</pre>
        </div>
    </div>
    <p>
Return <tt class=" ">true</tt> here to discard the attribute if it is <tt class=" ">undefined</tt>. If it is <tt class=" ">undefined</tt>, and this method returns <tt class=" ">true</tt>, the <tt class=" ">isDiscardExpressions</tt>, <tt class=" ">isOperationParameterDiscardable</tt> and <tt class=" ">isResourceAttributeDiscardable</tt> methods will not get called.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Gets whether the given operation parameter can be discarded
     *
     * @param address the address of the operation
     * @param attributeName the name of the operation parameter.
     * @param attributeValue the value of the operation parameter.
     * @param operation the operation executed. This is unmodifiable.
     * @param context the context of the transformation
     *
     * @return {@code true} if the operation parameter value should be discarded, {@code false} otherwise.
     */
    boolean isOperationParameterDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</pre>
        </div>
    </div>
    <p>
If we are transforming an operation, this method gets called for each operation parameter. We have access to the address of the operation,  the name and value of the operation parameter, an unmodifiable copy of the original operation and the <tt class=" ">TransformationContext</tt>. The <tt class=" ">TransformationContext</tt> allows you access to the original resource the operation is working on before any transformation happened, which is useful if you want to check other values in the resource if this is, say a <tt class=" ">write-attribute</tt> operation. Return <tt class=" ">true</tt> to discard the operation.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Gets whether the given attribute can be discarded
     *
     * @param address the address of the resource
     * @param attributeName the name of the attribute
     * @param attributeValue the value of the attribute
     * @param context the context of the transformation
     *
     * @return {@code true} if the attribute value should be discarded, {@code false} otherwise.
     */
    boolean isResourceAttributeDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</pre>
        </div>
    </div>
    <p>
If we are transforming a resource, this method gets called for each attribute in the resource. We have access to the address of the resource,  the name and value of the attribute, and the <tt class=" ">TransformationContext</tt>. Return <tt class=" ">true</tt> to discard the operation.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">}</pre>
        </div>
    </div>
    </div>
    
    <div class="section-5"  id="80873455_DomainModeSubsystemTransformers-DiscardAttributeCheckerhelperclasses%2Fimplementations"  >
        <h5>DiscardAttributeChecker helper classes/implementations</h5>
    
    <p>
<tt class=" ">DiscardAttributeChecker</tt> contains a few helper implementations for the most common cases to save you writing the same stuff again and again.    </p>
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.DefaultDiscardAttribut..."  >
        <h6>DiscardAttributeChecker.DefaultDiscardAttributeChecker</h6>
    
    <p>
<tt class=" ">DiscardAttributeChecker.DefaultDiscardAttributeChecker</tt> is an abstract convenience class. In most cases you don't need a separate check for if an operation or a resource is being transformed, so it makes both the <tt class=" ">isResourceAttributeDiscardable()</tt> and <tt class=" ">isOperationParameterDiscardable()</tt> methods call the following method.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">protected abstract boolean isValueDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</pre>
        </div>
    </div>
    <p>
All you loose, in the case of an operation transformation, is the name of the transformed operation. The constructor of <tt class=" ">DiscardAttributeChecker.DefaultDiscardAttributeChecker</tt> also allows you to define values for <tt class=" ">isDiscardExpressions()</tt> and <tt class=" ">isDiscardUndefined()</tt>.    </p>
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.DiscardAttributeValueC..."  >
        <h6>DiscardAttributeChecker.DiscardAttributeValueChecker</h6>
    
    <p>
This is another convenience class, which allows you to discard an attribute if it has one or more values. Here is a real-world example from the <tt class=" ">jpa</tt> subsystem:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private void initializeTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .setDiscard(
                   new DiscardAttributeChecker.DiscardAttributeValueChecker(new ModelNode(ExtendedPersistenceInheritance.DEEP.toString())),
                   JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .addRejectCheck(RejectAttributeChecker.DEFINED, JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));
    }</pre>
        </div>
    </div>
    <p>
We will come back to the reject checks in the <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Rejectingattributes">Rejecting attributes</a> section. We are saying that we should discard the <tt class=" ">JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</tt> attribute if it has the value <tt class=" ">deep</tt>. The reasoning here is that this attribute did not exist in the old model, but the legacy slave HCs <i class=" ">implied behaviour</i> is that this was <tt class=" ">deep</tt>. In the current version we added the possibility to toggle this setting, but only <tt class=" ">deep</tt> is consistent with what is available in the legacy slave HC. In this case we are using the constructor for <tt class=" ">DiscardAttributeChecker.DiscardAttributeValueChecker</tt> which says don't discard if it uses expressions, and discard if it is <tt class=" ">undefined</tt>. If it is <tt class=" ">undefined</tt> in the current model, looking at the default value of <tt class=" ">JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</tt>, it is <tt class=" ">deep</tt>, so a discard is in line with the implied legacy behaviour. If an expression is used, we cannot discard since we have no idea what the expression will resolve to on the slave HC.    </p>
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.ALWAYS"  >
        <h6>DiscardAttributeChecker.ALWAYS</h6>
    
    <p>
<tt class=" ">DiscardAttributeChecker.ALWAYS</tt> will always discard an attribute. Use this sparingly, since normally the presence of an attribute in the current model implies some behaviour should be turned on, and if that does not exist in the legacy model it implies that that behaviour does not exist in the legacy slave HC and its servers. Normally the legacy slave HC's subsystem has some implied behaviour which is better checked for by using a <tt class=" ">DiscardAttributeChecker.DiscardAttributeValueChecker</tt>. One valid use for <tt class=" ">DiscardAttributeChecker.ALWAYS</tt> can be found in the <tt class=" ">ejb3</tt> subsystem:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private static void registerTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance()
                .getAttributeBuilder()
                 ...
                // We can always discard this attribute, because it's meaningless without the security-manager subsystem, and
                // a legacy slave can't have that subsystem in its profile.
                .setDiscard(DiscardAttributeChecker.ALWAYS, EJB3SubsystemRootResourceDefinition.DISABLE_DEFAULT_EJB_PERMISSIONS)
   ...</pre>
        </div>
    </div>
    <p>
As the comment says, this attribute only makes sense with the security-manager susbsystem, which does not exist on legacy slaves running ModelVersion 1.1.0 of the <tt class=" ">ejb3</tt> subsystem.    </p>
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.UNDEFINED"  >
        <h6>DiscardAttributeChecker.UNDEFINED</h6>
    
    <p>
<tt class=" ">DiscardAttributeChecker.UNDEFINED</tt> will discard an attribute if it is <tt class=" ">undefined</tt>. This is normally safer than <tt class=" ">DiscardAttributeChecker.ALWAYS</tt> since the attribute is not set in the current model, we don't need to send it to the legacy model. However, you should check that this attribute not existing in the legacy slave HC, implies the same functionality as being undefined in the current DC.    </p>
    </div>
    
    </div>
    
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Rejectingattributes"  >
        <h4>Rejecting attributes</h4>
    
    <p>
The next step is to check attributes and values which we know for sure will not work on the target legacy slave HC.    </p>
    <p>
To reject an attribute we need an instance of <tt class=" ">org.jboss.as.controller.transform.description.RejectAttributeChecker</tt>, and call the following method on the <tt class=" ">AttributeTransformationDescriptionBuilder</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     RejectAttributeChecker rejectCheckerA = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, &quot;attr1&quot;, &quot;attr2&quot;);</pre>
        </div>
    </div>
    <p>
As shown you can register the <tt class=" ">RejectAttributeChecker</tt> for several attributes at once, in the above example both <tt class=" ">attr1</tt> and <tt class=" ">attr2</tt> get checked for if they should be discarded. You can also register different <tt class=" ">RejectAttributeChecker</tt> instances for different attributes:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     RejectAttributeChecker rejectCheckerA = ....;
     RejectAttributeChecker rejectCheckerB = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, &quot;attr1&quot;);
     attributeBuilder.addRejectCheck(rejectCheckerB, &quot;attr2&quot;);</pre>
        </div>
    </div>
    <p>
You can also register several <tt class=" ">RejectAttributeChecker</tt> instances per attribute    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     RejectAttributeChecker rejectCheckerA = ....;
     RejectAttributeChecker rejectCheckerB = ....;
     attributeBuilder.addRejectCheck(rejectCheckerA, &quot;attr1&quot;);
     attributeBuilder.addRejectCheck(rejectCheckerB, &quot;attr1, &quot;attr2&quot;);</pre>
        </div>
    </div>
    <p>
In this case <tt class=" ">attr1</tt> gets both <tt class=" ">rejectCheckerA</tt> and <tt class=" ">rejectCheckerB</tt>. For attributes with several <tt class=" ">RejectAttributeChecker</tt> registered, they get processed in the order that they have been added. So when checking <tt class=" ">attr1</tt> for rejection, <tt class=" ">rejectCheckerA</tt> gets run before <tt class=" ">rejectCheckerB</tt>. As mentioned in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-Attributetransformationlifecycle">Attribute transformation lifecycle</a>, if an attribute is rejected, we still invoke the rest of the reject checkers.    </p>
    <div class="section-5"  id="80873455_DomainModeSubsystemTransformers-TheRejectAttributeCheckerinterface"  >
        <h5>The RejectAttributeChecker interface</h5>
    
    <p>
<tt class=" ">org.jboss.as.controller.transform.description.RejectAttributeChecker</tt> contains both the <tt class=" ">RejectAttributeChecker</tt> and some helper implementations. The implementations of this interface get called for each attribute they are registered against. The interface itself is quite simple, and its main methods are similar to <tt class=" ">DiscardAttributeChecker</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public interface RejectAttributeChecker {
    /**
     * Determines whether the given operation parameter value is not understandable by the target process and needs
     * to be rejected.
     *
     * @param address        the address of the operation
     * @param attributeName  the name of the attribute
     * @param attributeValue the value of the attribute
     * @param operation      the operation executed. This is unmodifiable.
     * @param context        the context of the transformation
     * @return {@code true} if the parameter value is not understandable by the target process and so needs to be rejected, {@code false} otherwise.
     */
    boolean rejectOperationParameter(PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</pre>
        </div>
    </div>
    <p>
If we are transforming an operation, this method gets called for each operation parameter. We have access to the address of the operation,  the name and value of the operation parameter, an unmodifiable copy of the original operation and the <tt class=" ">TransformationContext</tt>. The <tt class=" ">TransformationContext</tt> allows you access to the original resource the operation is working on before any transformation happened, which is useful if you want to check other values in the resource if this is, say a <tt class=" ">write-attribute</tt> operation. Return <tt class=" ">true</tt> to reject the operation.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Gets whether the given resource attribute value is not understandable by the target process and needs
     * to be rejected.
     *
     * @param address        the address of the resource
     * @param attributeName  the name of the attribute
     * @param attributeValue the value of the attribute
     * @param context        the context of the transformation
     * @return {@code true} if the attribute value is not understandable by the target process and so needs to be rejected, {@code false} otherwise.
     */
    boolean rejectResourceAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</pre>
        </div>
    </div>
    <p>
If we are transforming a resource, this method gets called for each attribute in the resource. We have access to the address of the resource,  the name and value of the attribute, and the <tt class=" ">TransformationContext</tt>. Return <tt class=" ">true</tt> to discard the operation.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Returns the log message id used by this checker. This is used to group it so that all attributes failing a type of rejction
     * end up in the same error message
     *
     * @return the log message id
     */
    String getRejectionLogMessageId();</pre>
        </div>
    </div>
    <p>
Here we need a unique id for the log message from the <tt class=" ">RejectAttributeChecker</tt>. It is used to group rejected attributes by their log message. A typical implementation will contain {{return getRejectionLogMessage(Collections.&lt;String, ModelNode&gt;emptyMap());}    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Gets the log message if the attribute failed rejection
     *
     * @param attributes a map of all attributes failed in this checker and their values
     * @return the formatted log message
     */
    String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes);</pre>
        </div>
    </div>
    <p>
Here we return a message saying why the attributes were rejected, with the possiblity to format the message to include the names of all the rejected attributes and the values they had.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">}</pre>
        </div>
    </div>
    </div>
    
    <div class="section-5"  id="80873455_DomainModeSubsystemTransformers-RejectAttributeCheckerhelperclasses%2Fimplementations"  >
        <h5>RejectAttributeChecker helper classes/implementations</h5>
    
    <p>
<tt class=" ">RejectAttributeChecker</tt> contains a few helper classes for the most common scenarios to save you from writing the same stuff again and again.    </p>
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.DefaultRejectAttributeC..."  >
        <h6>RejectAttributeChecker.DefaultRejectAttributeChecker</h6>
    
    <p>
<tt class=" ">RejectAttributeChecker.DefaultRejectAttributeChecker</tt> is an abstract convenience class. In most cases you don't need a separate check for if an operation or a resource is being transformed, so it makes both the <tt class=" ">rejectOperationParameter()</tt> and <tt class=" ">rejectResourceAttribute()</tt> methods call the following method.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">protected abstract boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</pre>
        </div>
    </div>
    <p>
Like <tt class=" ">DefaultDiscardAttributeChecker</tt>, all you loose is the name of the transformed operation, in the case of operation transformation.    </p>
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.DEFINED"  >
        <h6>RejectAttributeChecker.DEFINED</h6>
    
    <p>
<tt class=" ">RejectAttributeChecker.DEFINED</tt> is used to reject any attribute that has a defined value. Normally this is because the attribute does not exist on the target legacy slave HC. A typical use case for these is for the <i class=" ">implied behaviour</i> example we looked at in the <tt class=" ">jpa</tt> subsystem in <a href="Domain_Mode_Subsystem_Transformers.html#80873455_DomainModeSubsystemTransformers-DiscardAttributeChecker.DiscardAttributeValueC...">DiscardAttributeChecker.DiscardAttributeValueChecker</a>    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private void initializeTransformers_1_1_0(SubsystemRegistration subsystemRegistration) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .setDiscard(
                   new DiscardAttributeChecker.DiscardAttributeValueChecker(new ModelNode(ExtendedPersistenceInheritance.DEEP.toString())),
                   JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .addRejectCheck(RejectAttributeChecker.DEFINED, JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystemRegistration, ModelVersion.create(1, 1, 0));
    }</pre>
        </div>
    </div>
    <p>
So we discard the <tt class=" ">JPADefinition.DEFAULT_EXTENDEDPERSISTENCE_INHERITANCE</tt> value if it is not an expression, and also has the value <tt class=" ">deep</tt>. Now if it was not discarded, it would will still be defined so we reject it.    </p>
    <div class="confbox admonition admonition-info">
            <div class="title">Important</div>
        
    <p>
Reject and discard often work in pairs.    </p>
    </div>
    
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.SIMPLEEXPRESSIONS"  >
        <h6>RejectAttributeChecker.SIMPLE_EXPRESSIONS</h6>
    
    <p>
<tt class=" ">RejectAttributeChecker.SIMPLE_EXPRESSIONS</tt> can be used to reject an attribute that contains expressions. This was used a lot for transformations to subsystems in JBoss AS 7.1.x, since we had not fully realized the importance of where to support expressions until JBoss AS 7.2.0 was released, so a lot of attributes in earlier versions were missing expressions support.    </p>
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.ListRejectAttributeChecker"  >
        <h6>RejectAttributeChecker.ListRejectAttributeChecker</h6>
    
    <p>
The <tt class=" ">RejectAttributeChecker}}s we have seen so far work on simple attributes, i.e. where the attribute has a ModelType which is one of the primitives. We also have a {{RejectAttributeChecker.ListRejectAttributeChecker</tt> which allows you to define a checker for the elements of a list, when the type of an attribute is <tt class=" ">ModelType.LIST</tt>.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    attributeBuilder
            .addRejectCheck(new ListRejectAttributeChecker(RejectAttributeChecker.EXPRESSIONS), &quot;attr1&quot;);</pre>
        </div>
    </div>
    <p>
For <tt class=" ">attr1</tt> it will check each element of the list and run <tt class=" ">RejectAttributeChecker.EXPRESSIONS</tt> to check that each element is not an expression. You can of course pass in another kind of <tt class=" ">RejectAttributeChecker</tt> to check the elements as well.    </p>
    </div>
    
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-RejectAttributeChecker.ObjectFieldsRejectAttri..."  >
        <h6>RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</h6>
    
    <p>
For attributes where the type is <tt class=" ">ModelType.OBJECT</tt> we have <tt class=" ">RejectAttributeChecker.ObjectFieldsRejectAttributeChecker</tt> which allows you to register different reject checkers for the different fields of the registered object.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    Map&lt;String, RejectAttributeChecker&gt; fieldRejectCheckers = new HashMap&lt;String, RejectAttributeChecker&gt;();
    fieldRejectCheckers.put(&quot;time&quot;, RejectAttributeChecker.SIMPLE_EXPRESSIONS);
    fieldRejectCheckers.put(&quot;unit&quot;, &quot;Lunar Month&quot;);
    attributeBuilder
            .addRejectCheck(new ObjectFieldsRejectAttributeChecker(fieldRejectCheckers), &quot;attr1&quot;);</pre>
        </div>
    </div>
    <p>
Now if <tt class=" ">attr1</tt> is a complex type where <tt class=" ">attr1.get(&quot;time&quot;).getType() == ModelType.EXPRESSION</tt> or <tt class=" ">attr1.get(&quot;unit&quot;).asString().equals(&quot;Lunar Month&quot;)</tt> we reject the attribute.    </p>
    </div>
    
    </div>
    
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Convertingattributes"  >
        <h4>Converting attributes</h4>
    
    <p>
To convert an attribute you register an <tt class=" ">org.jboss.as.controller.transform.description.AttributeConverter</tt> instance against the attributes you want to convert:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    AttributeConverter converterA = ...;
    AttributeConverter converterB = ...;
    attributeBuilder
            .setValueConverter(converterA, &quot;attr1&quot;, &quot;attr2&quot;);
    attributeBuilder
            .setValueConverter(converterB, &quot;attr3&quot;);</pre>
        </div>
    </div>
    <p>
Now if <tt class=" ">attr1</tt> and <tt class=" ">attr2</tt> get converted with <tt class=" ">converterA</tt>, while <tt class=" ">attr3</tt> gets converted with <tt class=" ">converterB</tt>.    </p>
    <div class="section-5"  id="80873455_DomainModeSubsystemTransformers-TheAttributeConverterinterface"  >
        <h5>The AttributeConverter interface</h5>
    
    <p>
The <tt class=" ">AttributeConverter</tt> interface gets called for each attribute for which the <tt class=" ">AttributeConverter</tt> has been registered    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public interface AttributeConverter {

    /**
     * Converts an operation parameter
     *
     * @param address the address of the operation
     * @param attributeName the name of the operation parameter
     * @param attributeValue the value of the operation parameter to be converted
     * @param operation the operation executed. This is unmodifiable.
     * @param context the context of the transformation
     */
    void convertOperationParameter(PathAddress address, String attributeName, ModelNode attributeValue, ModelNode operation, TransformationContext context);</pre>
        </div>
    </div>
    <p>
If we are transforming an operation, this method gets called for each operation parameter for which the con. We have access to the address of the operation, the name and value of the operation parameter, an unmodifiable copy of the original operation and the <tt class=" ">TransformationContext</tt>. The <tt class=" ">TransformationContext</tt> allows you access to the original resource the operation is working on before any transformation happened, which is useful if you want to check other values in the resource if this is, say a write-attribute operation. To change the attribute value, you modify the <tt class=" ">attributeValue</tt>.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Converts a resource attribute
     *
     * @param address the address of the operation
     * @param attributeName the name of the attribute
     * @param attributeValue the value of the attribute to be converted
     * @param context the context of the transformation
     */
    void convertResourceAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</pre>
        </div>
    </div>
    <p>
If we are transforming a resource, this method gets called for each attribute in the resource. We have access to the address of the resource, the name and value of the attribute, and the <tt class=" ">TransformationContext</tt>. To change the attribute value, you modify the <tt class=" ">attributeValue</tt>.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">}</pre>
        </div>
    </div>
    <p>
A hypothetical example is if the current and legacy subsystems both contain an attribute called <tt class=" ">timeout</tt>. In the legacy model this was specified to be milliseconds, however in the current model it has been changed to be seconds, hence we need to convert the value when sending it to slave HCs using the legacy model:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     AttributeConverter secondsToMs = new AttributeConverter.DefaultAttributeConverter() {
                  @Override
                  protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue,
                           TransformationContext context) {
                      if (attributeValue.isDefined()) {
                           int seconds = attributeValue.asInt();
                           int milliseconds = seconds * 1000;
                           attributeValue.set(milliseconds);
                      }
                  }
          };
    
     attributeBuilder.
          .setValueConverter(secondsToMs , &quot;timeout&quot;)</pre>
        </div>
    </div>
    <p>
We need to be a bit careful here. If the <tt class=" ">timeout</tt> attribute is an expression our nice conversion will not work, so we need to add a reject check to make sure it is not an expression as well:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     attributeBuilder.
          .addRejectCheck(SIMPLE_EXPRESSIONS, &quot;timeout&quot;)
          .setValueConverter(secondsToMs , &quot;timeout&quot;)</pre>
        </div>
    </div>
    <p>
Now it should be fine.    </p>
    <p>
<tt class=" ">AttributeConverter.DefaultAttributeConverter</tt> is is an abstract convenience class. In most cases you don't need a separate check for if an operation or a resource is being transformed, so it makes both the convertOperationParameter() and convertResourceAttribute() methods call the following method.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">protected abstract void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context);</pre>
        </div>
    </div>
    <p>
Like <tt class=" ">DefaultDiscardAttributeChecker</tt> and <tt class=" ">DefaultRejectAttributeChecker</tt>, all you loose is the name of the transformed operation, in the case of operation transformation.    </p>
    <div class="section-6"  id="80873455_DomainModeSubsystemTransformers-Introducingattributesduringtransformation"  >
        <h6>Introducing attributes during transformation</h6>
    
    <p>
Say both the current and the legacy models have an attribute called <tt class=" ">port</tt>. In the legacy version this attribute had to be specified, and the default xml configuration had <tt class=" ">1234</tt> for its value. In the current version this attribute has been made optional with a default value of <tt class=" ">1234</tt> so that it does not need to be specified. When transforming to a slave HC using the old version we will need to introduce this attribute if the new model does not contain it:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     attributeBuilder.
         setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode(1234) true), &quot;port&quot;);</pre>
        </div>
    </div>
    <p>
So what this factory method does is to create an implementation of <tt class=" ">AttributeConverter.DefaultAttributeConverter</tt> where in <tt class=" ">convertAttribute()</tt> we set <tt class=" ">attributeValue</tt> to have the value <tt class=" ">1234</tt> if it is <tt class=" ">undefined</tt>. As long as <tt class=" ">attributeValue</tt> gets set in that method it will get set in the model, regardless of if it existed already or not.    </p>
    </div>
    
    </div>
    
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Renamingattributes"  >
        <h4>Renaming attributes</h4>
    
    <p>
To rename an attribute, you simply do    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    attributeBuilder.addRename(&quot;my-name&quot;, &quot;legacy-name&quot;);</pre>
        </div>
    </div>
    <p>
Now, in the initial domain transfer to the legacy slave HC, we rename <tt class=" ">/subsystem=my-subsystem</tt>'s <tt class=" ">my-name</tt> attribute to <tt class=" ">legacy-name</tt>. Also, the operations involving this attribute are affected, so    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /subsystem=my-subsystem/:add(my-name=true)  -&gt;  
         /subsystem=my-subsystem/:add(legacy-name=true)
    /subsystem=my-subsystem:write-attribute(name=my-name, value=true) -&gt; 
         /subsystem=my-subsystem:write-attribute(name=legacy-name, value=true)
    /subsystem=my-subsystem:undefine-attribute(name=my-name) -&gt; 
         /subsystem=my-subsystem:undefine-attribute(name=legacy-name)</pre>
        </div>
    </div>
    </div>
    
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-OperationTransformationOverrideBuilder"  >
        <h3>OperationTransformationOverrideBuilder</h3>
    
    <p>
All operations on a resource automatically get the same transformations on their parameters as set up by the <tt class=" ">AttributeTransformationDescriptionBuilder</tt>. In some cases you might want to change this, so you can use the <tt class=" ">OperationTransformationOverrideBuilder</tt>, which is got from:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride(&quot;some-operation&quot;);</pre>
        </div>
    </div>
    <p>
In this case the operation will now no longer inherit the attribute/operation parameter transformations, so they are effectively turned off. In other cases you might want to include them by calling <tt class=" ">inheritResourceAttributeDefinitions()</tt>, and to include some more checks (the <tt class=" ">OperationTransformationBuilder</tt> interface has all the methods found in <tt class=" ">AttributeTransformationBuilder</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride(&quot;some-operation&quot;);
    operationBuilder.inheritResourceAttributeDefinitions();
    operationBuilder.setValueConverter(AttributeConverter.Factory.createHardCoded(new ModelNode(1234) true), &quot;port&quot;);</pre>
        </div>
    </div>
    <p>
You can also rename operations, in this case the operation <tt class=" ">some-operation</tt> gets renamed to <tt class=" ">legacy-operation</tt> before getting sent to the legacy slave HC.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    OperationTransformationOverrideBuilder operationBuilder = subSystemBuilder.addOperationTransformationOverride(&quot;some-operation&quot;);
    operationBuilder.rename(&quot;legacy-operation&quot;);</pre>
        </div>
    </div>
    </div>
    
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-EvolvingtransformerswithsubsystemModelVersions"  >
        <h2>Evolving transformers with subsystem ModelVersions</h2>
    
    <p>
Say you have a subsystem with ModelVersions 1.0.0 and 1.1.0. There will (hopefully!) already be transformers in place for 1.1.0 to 1.0.0 transformations. Let's say that the transformers registration looks like:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public class SomeExtension implements Extension {
 
    private static final String SUBSYSTEM_NAME = &quot;my-subsystem&quot;'
  
    private static final int MANAGEMENT_API_MAJOR_VERSION = 1;
    private static final int MANAGEMENT_API_MINOR_VERSION = 1;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;
 
    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }
 
    private void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_0_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.0.0
     */
    private void registerTransformers_1_0_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, &quot;attr1&quot;)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }
}</pre>
        </div>
    </div>
    <p>
Now say we want to do a new version of the model. This new version contains a new attribute called 'new-attr' which cannot be defined when transforming to 1.1.0, we bump the model version to 2.0.0:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">public class SomeExtension implements Extension {
 
    private static final String SUBSYSTEM_NAME = &quot;my-subsystem&quot;'
  
    private static final int MANAGEMENT_API_MAJOR_VERSION = 2;
    private static final int MANAGEMENT_API_MINOR_VERSION = 0;
    private static final int MANAGEMENT_API_MICRO_VERSION = 0;

    @Override
    public void initialize(ExtensionContext context) {
        SubsystemRegistration registration = context.registerSubsystem(SUBSYSTEM_NAME, MANAGEMENT_API_MAJOR_VERSION,
                MANAGEMENT_API_MINOR_VERSION, MANAGEMENT_API_MICRO_VERSION);
        //Register the resource definitions
        ....
    }</pre>
        </div>
    </div>
    <p>
Now we need some new transformers from the current ModelVersion to 1.1.0 where we reject any defined occurrances of our new attribute <tt class=" ">new-attr</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private void registerTransformers(final SubsystemRegistration subsystem) {
        registerTransformers_1_0_0(subsystem);
        registerTransformers_1_1_0(subsystem);
    }
 
    /**
     * Registers transformers from the current version to ModelVersion 1.1.0
     */
    private void registerTransformers_1_1_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, &quot;new-attr&quot;)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 1, 0));
    }</pre>
        </div>
    </div>
    <p>
So that is all well and good, however we also need to take into account that <strong class=" "><tt class=" ">new-attr</tt> does not exist in ModelVersion 1.0.0 either</strong>, so we need to extend our transformer for 1.0.0  to reject it there as well    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    /**
     * Registers transformers from the current version to ModelVersion 1.0.0
     */
    private void registerTransformers_1_0_0(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.getAttributeBuilder()
            .addRejectCheck(RejectAttributeChecker.DEFINED, &quot;attr1&quot;, &quot;new-attr&quot;)
            .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }
}</pre>
        </div>
    </div>
    <p>
Now <tt class=" ">new-attr</tt> will be rejected if defined for all previous model versions.    </p>
    <p>
<strong class=" "><i class=" ">It has been pointed out that this approach does not really scale as the number of old versions increases, <a href="https://issues.jboss.org/browse/WFLY-2512">https://issues.jboss.org/browse/WFLY-2512</a> is a suggestion to only need to implement transformers for each version delta</i></strong>    </p>
    <p>
To test transformation you need to extend <tt class=" ">org.jboss.as.subsystem.test.AbstractSubsystemTest</tt> or <tt class=" ">org.jboss.as.subsystem.test.AbstractSubsystemBaseTest</tt>. Then, in order to have the best test coverage possible, you should test the fullest configuration that will work, and you should also test configurations that don't work if you have rejecting transformers registered. The following example is from the threads subsystem, and I have only included the tests against 7.1.2 - there are more! First we need to set up our test:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;"> 
public class ThreadsSubsystemTestCase extends AbstractSubsystemBaseTest {
    public ThreadsSubsystemTestCase() {
        super(ThreadsExtension.SUBSYSTEM_NAME, new ThreadsExtension());
    }

    @Override
    protected String getSubsystemXml() throws IOException {
        return readResource(&quot;threads-subsystem-1_1.xml&quot;);
    }</pre>
        </div>
    </div>
    <p>
    </p>
    <p>
So we say that this test is for the <tt class=" ">threads</tt> subsystem, and that it is implemented by <tt class=" ">ThreadsExtension</tt>. This is the same test framework as we use in <a href="Example_subsystem.html#80873445_Examplesubsystem-Testingtheparsers">Example subsystem#Testing the parsers</a>, but we will only talk about the parts relevant to transformers here.    </p>
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Testingaconfigurationthatworks"  >
        <h3>Testing a configuration that works</h3>
    
    <p>
To test a configuration xxx    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    @Test
    public void testTransformerAS712() throws Exception {
        testTransformer_1_0(ModelTestControllerVersion.V7_1_2_FINAL);
    }
    /**
     * Tests transformation of model from 1.1.0 version into 1.0.0 version.
     *
     * @throws Exception
     */
    private void testTransformer_1_0(ModelTestControllerVersion controllerVersion) throws Exception {
        String subsystemXml = &quot;threads-transform-1_0.xml&quot;;   //This has no expressions not understood by 1.0
        ModelVersion modelVersion = ModelVersion.create(1, 0, 0); //The old model version
        //Use the non-runtime version of the extension which will happen on the HC
        KernelServicesBuilder builder = createKernelServicesBuilder(AdditionalInitialization.MANAGEMENT)
                .setSubsystemXmlResource(subsystemXml);

        final PathAddress subsystemAddress = PathAddress.pathAddress(PathElement.pathElement(SUBSYSTEM, mainSubsystemName));

        // Add legacy subsystems
        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)
                .addOperationValidationResolve(&quot;add&quot;, subsystemAddress.append(PathElement.pathElement(&quot;thread-factory&quot;)))
                .addMavenResourceURL(&quot;org.jboss.as:jboss-as-threads:&quot; + controllerVersion.getMavenGavVersion())
                .excludeFromParent(SingleClassFilter.createFilter(ThreadsLogger.class)); 

        KernelServices mainServices = builder.build();
        KernelServices legacyServices = mainServices.getLegacyServices(modelVersion);
        Assert.assertNotNull(legacyServices);
        checkSubsystemModelTransformation(mainServices, modelVersion);
    }
</pre>
        </div>
    </div>
    <p>
What this test does is get the builder to configure the test controller using <tt class=" ">threads-transform-1_0.xml</tt>. This main builder works with the current subsystem version, and the jars in the WildFly checkout.    </p>
    <p>
Next we configure a 'legacy' controller. This will run the version of the core libraries (e.g the <tt class=" ">controller</tt> module) as found in the targeted legacy version of JBoss AS/Wildfly), and the subsystem. We need to pass in that it is using the core AS version 7.1.2.Final (i.e. the <tt class=" ">ModelTestControllerVersion.V7_1_2_FINAL</tt> part) and that that version is ModelVersion 1.0.0. Next we have some <tt class=" ">addMavenResourceURL()</tt> calls passing in the Maven GAVs of the old version of the subsystem and any dependencies it has needed to boot up. Normally, specifying just the Maven GAV of the old version of the subsystem is enough, but that depends on your subsystem. In this case the old subsystem GAV is enough. When booting up the legacy controller the framework uses the parsed operations from the main controller and transforms them using the 1.0.0 transformer in the threads subsystem. The <tt class=" ">addOperationValidationResolve()</tt> and <tt class=" ">excludeFromParent()</tt> calls are not normally necessary, see the javadoc for more examples.    </p>
    <p>
The call to <tt class=" ">KernelServicesBuilder.build()</tt> will build both the main controller and the legacy controller. As part of that it also boots up a second copy of the main controller using the transformed operations to make sure that the 'old' ops to boot our subsystem will still work on the current controller, which is important for backwards compatibility of CLI scripts. To tweak how that is done if you see failures there, see <tt class=" ">LegacyKernelServicesInitializer.skipReverseControllerCheck()</tt> and <tt class=" ">LegacyKernelServicesInitializer.configureReverseControllerCheck()</tt>. The <tt class=" ">LegacyKernelServicesInitializer</tt> is what gets returned by <tt class=" ">KernelServicesBuilder.createLegacyKernelServicesBuilder()</tt>.    </p>
    <p>
Finally we call <tt class=" ">checkSubsystemModelTransformation()</tt> which reads the full legacy subsystem model. The legacy subsystem model will have been built up from the transformed boot operations from the parsed xml. The operations get transformed by the operation transformers. Then it takes the model of the current subsystem and transforms that using the resource transformers. Then it compares the two models, which should be the same. In some rare cases it is not possible to get those two models exactly the same, so there is a version of this method that takes a <tt class=" ">ModelFixer</tt> to make adjustments. The <tt class=" ">checkSubsystemModelTransformation()</tt> method also makes sure that the legacy model is valid according to the legacy subsystem's resource definition. These legacy subsystem resource defintion's are stored in <tt class=" ">subsystem-test/framework/src/main/resources/org/jboss/as/subsystem/test</tt> and the file names are <tt class=" ">&lt;your-subsystem-name&gt;-&lt;legacy-version&gt;.dmr. If this file does not exist, you need to generate it by adding a temporary test (make sure that you adjust {{controllerVersion</tt> and <tt class=" ">modelVersion</tt> to what you want to generate):    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    @Test
    public void deleteMeWhenDone() throws Exception {
        ModelTestControllerVersion controllerVersion = ModelTestControllerVersion.V7_1_2_FINAL;
        ModelVersion modelVersion = ModelVersion.create(1, 0, 0);
        KernelServicesBuilder builder = createKernelServicesBuilder(null);

        builder.createLegacyKernelServicesBuilder(null, controllerVersion, modelVersion)
            .addMavenResourceURL(&quot;org.jboss.as:jboss-as-threads:&quot; + controllerVersion.getMavenGavVersion());
        KernelServices services = builder.build();

        generateLegacySubsystemResourceRegistrationDmr(services, modelVersion);
    }</pre>
        </div>
    </div>
    <p>
Now run the test and delete it. The legacy .dmr file should be in <tt class=" ">target/test-classes/org/jboss/as/subsystem/test/&lt;your-subsystem-name&gt;-&lt;your-version&gt;.dmr</tt>. Copy this .dmr file to <tt class=" ">subsystem-test/framework/src/main/resources/org/jboss/as/subsystem/test</tt>. You will likely also need to update <tt class=" ">org.jboss.as.subsystem.test.KnownVersions</tt> to include your latest legacy subsystem version, once you start doing real testing.    </p>
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Testingaconfigurationthatdoesnotwork"  >
        <h3>Testing a configuration that does not work</h3>
    
    <p>
The <tt class=" ">threads</tt> subsystem (like several others) did not support the use of expression values in the version that came with JBoss AS 7.1.2.Final. So we have a test that attempts to use expressions, and then fixes each resource and attribute where expressions were not allowed.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    @Test
    public void testRejectExpressionsAS712() throws Exception {
        testRejectExpressions_1_0_0(ModelTestControllerVersion.V7_1_2_FINAL);
    }

    private void testRejectExpressions_1_0_0(ModelTestControllerVersion controllerVersion) throws Exception {
        // create builder for current subsystem version
        KernelServicesBuilder builder = createKernelServicesBuilder(createAdditionalInitialization());

        // create builder for legacy subsystem version
        ModelVersion version_1_0_0 = ModelVersion.create(1, 0, 0);
        builder.createLegacyKernelServicesBuilder(null, controllerVersion, version_1_0_0)
                .addMavenResourceURL(&quot;org.jboss.as:jboss-as-threads:&quot; + controllerVersion.getMavenGavVersion())
                .excludeFromParent(SingleClassFilter.createFilter(ThreadsLogger.class));

        KernelServices mainServices = builder.build();
        KernelServices legacyServices = mainServices.getLegacyServices(version_1_0_0);

        Assert.assertNotNull(legacyServices);
        Assert.assertTrue(&quot;main services did not boot&quot;, mainServices.isSuccessfulBoot());
        Assert.assertTrue(legacyServices.isSuccessfulBoot());

        List&lt;ModelNode&gt; xmlOps = builder.parseXmlResource(&quot;expressions.xml&quot;);

        ModelTestUtils.checkFailedTransformedBootOperations(mainServices, version_1_0_0, xmlOps, getConfig());
    }</pre>
        </div>
    </div>
    <p>
Again we boot up a current and a legacy controller. However, note in this case that they are both empty, no xml was parsed on boot so there are no operations to boot up the model. Instead once the controllers have been booted, we call <tt class=" ">KernelServicesBuilder.parseXmlResource()</tt> which gets the operations from <tt class=" ">expressions.xml</tt>. <tt class=" ">expressions.xml</tt> uses expressions in all the places they were not allowed in 7.1.2.Final. For each resource <tt class=" ">ModelTestUtils.checkFailedTransformedBootOperations()</tt> will check that the <tt class=" ">add</tt> operation gets rejected, and then correct one attribute at a time until the resource has been totally corrected. Once the <tt class=" ">add</tt> operation is totally correct, it will check that the add operation no longer is rejected. The configuration for this is the <tt class=" ">FailedOperationTransformationConfig</tt> returned by the <tt class=" ">getConfig()</tt> method:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private FailedOperationTransformationConfig getConfig() {
        PathAddress subsystemAddress = PathAddress.pathAddress(ThreadsExtension.SUBSYSTEM_PATH);
        FailedOperationTransformationConfig.RejectExpressionsConfig allowedAndKeepalive =
                new FailedOperationTransformationConfig.RejectExpressionsConfig(PoolAttributeDefinitions.ALLOW_CORE_TIMEOUT, PoolAttributeDefinitions.KEEPALIVE_TIME);
...
        return new FailedOperationTransformationConfig()
                .addFailedAttribute(subsystemAddress.append(PathElement.pathElement(CommonAttributes.BLOCKING_BOUNDED_QUEUE_THREAD_POOL)),
                        allowedAndKeepalive)
                .addFailedAttribute(subsystemAddress.append(PathElement.pathElement(CommonAttributes.BOUNDED_QUEUE_THREAD_POOL)),
                        allowedAndKeepalive)
    }</pre>
        </div>
    </div>
    <p>
So what this means is that we expect the <tt class=" ">allow-core-timeout</tt> and <tt class=" ">keepalive-time</tt> attributes for the <tt class=" ">blocking-bounded-queue-thread-pool=*</tt> and <tt class=" ">bounded-queue-thread-pool=*</tt> add operations to use expressions in the parsed xml. We then expect them to fail since there should be transformers in place to reject expressions, and correct them one at a time until the add operation should pass. As well as doing the <tt class=" ">add</tt> operations the <tt class=" ">ModelTestUtils.checkFailedTransformedBootOperations()</tt> method will also try calling <tt class=" ">write-attribute</tt> for each attribute, correcting as it goes along. As well as allowing you to test rejection of expressions <tt class=" ">FailedOperationTransformationConfig</tt> also has some helper classes to help testing rejection of other scenarios.    </p>
    </div>
    
    </div>
    
    <div class="section-2"  id="80873455_DomainModeSubsystemTransformers-Commontransformationusecases"  >
        <h2>Common transformation use-cases</h2>
    
    <p>
Most transformations are quite similar, so this section covers some of the actual transformation patterns found in the WildFly codebase. We will look at the output of CompareModelVersionsUtil, and see what can be done to transform for the older slave HCs. The examples come from the WildFly codebase but are stripped down to focus solely on the use-case being explained in an attempt to keep things as clear/simple as possible.    </p>
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Childresourcetypedoesnotexistinlegacymodel"  >
        <h3>Child resource type does not exist in legacy model</h3>
    
    <p>
Looking at the model comparison between WildFly and JBoss AS 7.2.0, there is a change to the <tt class=" ">remoting</tt> subsystem. The relevant part of the output is:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">====== Resource root address: [&quot;subsystem&quot; =&gt; &quot;remoting&quot;] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
Missing child types in current: []; missing in legacy [http-connector]</pre>
        </div>
    </div>
    <p>
So our current model has added a child type called <tt class=" ">http-connector</tt> which was not there in 7.2.0. This is configurable, and adds new behaviour, so it can not be part of a configuration sent across to a legacy slave running version 1.2.0. So we add the following to <tt class=" ">RemotingExtension</tt> to reject all instances of that child type against ModelVersion 1.2.0.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    @Override
    public void initialize(ExtensionContext context) {
        ....
        if (context.isRegisterTransformers()) {
            registerTransformers_1_1(registration);
            registerTransformers_1_2(registration);
        }
    }

    private void registerTransformers_1_2(SubsystemRegistration registration) {
        TransformationDescription.Tools.register(get1_2_0_1_3_0Description(), registration, VERSION_1_2);
    }

    private static TransformationDescription get1_2_0_1_3_0Description() {
        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory.createSubsystemInstance();
        builder.rejectChildResource(HttpConnectorResource.PATH);

        return builder.build();
    }</pre>
        </div>
    </div>
    <p>
Since this child resource type also does not exist in ModelVersion 1.1.0 we need to reject it there as well using a similar mechanism.    </p>
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Attributedoesnotexistinthelegacysubsystem"  >
        <h3>Attribute does not exist in the legacy subsystem</h3>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Defaultvalueoftheattributeisthesameaslegacyimpliedbehaviour"  >
        <h4>Default value of the attribute is the same as legacy implied behaviour</h4>
    
    <p>
This example also comes from the <tt class=" ">remoting</tt> subsystem, and is probably the most common type of transformation. The comparison tells us that there is now an attribute under <tt class=" ">/subsystem=remoting/remote-outbound-connection=*</tt> called <tt class=" ">protocol</tt> which did not exist in the older version:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">====== Resource root address: [&quot;subsystem&quot; =&gt; &quot;remoting&quot;] - Current version: 2.0.0; legacy version: 1.2.0 =======
--- Problems for relative address to root []:
....
--- Problems for relative address to root [&quot;remote-outbound-connection&quot; =&gt; &quot;*&quot;]:
Missing attributes in current: []; missing in legacy [protocol]
Missing parameters for operation 'add' in current: []; missing in legacy [protocol]</pre>
        </div>
    </div>
    <p>
This difference also affects the <tt class=" ">add</tt> operation. Looking at the current model the valid values for the <tt class=" ">protocol</tt> attribute are <tt class=" ">remote</tt>, <tt class=" ">http-remoting</tt> and <tt class=" ">https-remoting</tt>. The last two are new protocols introduced in WildFly 8, meaning that the <i class=" ">implied behaviour</i> in JBoss 7.2.0 and earlier is the <tt class=" ">remote</tt> protocol. Since this attribute does not exist in the legacy model we want to discard this attribute if it is <tt class=" ">undefined</tt> or if it has the value <tt class=" ">remote</tt>, both of which are in line with what the legacy slave HC is hardwired to use. Also we want to reject it if it has a value different from <tt class=" ">remote</tt>. So what we need to do when registering transformers against ModelVersion 1.2.0 to handle this attribute:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private void registerTransformers_1_2(SubsystemRegistration registration) {
        TransformationDescription.Tools.register(get1_2_0_1_3_0Description(), registration, VERSION_1_2);
    }

    private static TransformationDescription get1_2_0_1_3_0Description() {
        ResourceTransformationDescriptionBuilder builder = ResourceTransformationDescriptionBuilder.Factory.createSubsystemInstance();
        protocolTransform(builder.addChildResource(RemoteOutboundConnectionResourceDefinition.ADDRESS)
                .getAttributeBuilder());
        return builder.build();
    }

    private static AttributeTransformationDescriptionBuilder protocolTransform(AttributeTransformationDescriptionBuilder builder) {
        builder.setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(new ModelNode(Protocol.REMOTE.toString())), RemoteOutboundConnectionResourceDefinition.PROTOCOL)
                .addRejectCheck(RejectAttributeChecker.DEFINED, RemoteOutboundConnectionResourceDefinition.PROTOCOL);
        return builder;
    }</pre>
        </div>
    </div>
    <p>
So the first thing to happens is that we register a <tt class=" ">DiscardAttributeChecker.DiscardAttributeValueChecker</tt> which discards the attribute if it is either <tt class=" ">undefined</tt> (the default value in the current model is <tt class=" ">remote</tt>), or <tt class=" ">defined</tt> and has the value <tt class=" ">remote</tt>. Remembering that the <tt class=" ">discard</tt> phase always happens before the <tt class=" ">reject</tt> phase, the reject checker checks that the <tt class=" ">protocol</tt> attribute is defined, and rejects it if it is. The only reason it would be <tt class=" ">defined</tt> in the reject check, is if it was not discarded by the discard check. Hopefully this example shows that the discard and reject checkers often work in pairs.    </p>
    <p>
An alternative way to write the <tt class=" ">protocolTransform()</tt> method would be:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">     private static AttributeTransformationDescriptionBuilder protocolTransform(AttributeTransformationDescriptionBuilder builder) {
        builder.setDiscard(new DiscardAttributeChecker.DefaultDiscardAttributeChecker() {
                    @Override
                    protected boolean isValueDiscardable(final PathAddress address, final String attributeName, final ModelNode attributeValue, final TransformationCon
                        return !attributeValue.isDefined() || attributeValue.asString().equals(Protocol.REMOTE.toString());
                    }
                }, RemoteOutboundConnectionResourceDefinition.PROTOCOL)
         .addRejectCheck(RejectAttributeChecker.DEFINED, RemoteOutboundConnectionResourceDefinition.PROTOCOL);
         return builder;</pre>
        </div>
    </div>
    <p>
The reject check remains the same, but we have implemented the discard check by using <tt class=" ">DiscardAttributeChecker.DefaultDiscardAttributeChecker</tt> instead. However, the effect of the discard check is exactly the same as when we used <tt class=" ">DiscardAttributeChecker.DiscardAttributeValueChecker</tt>.    </p>
    </div>
    
    <div class="section-4"  id="80873455_DomainModeSubsystemTransformers-Defaultvalueoftheattributeisdifferentfromlegacyimpliedbehaviour"  >
        <h4>Default value of the attribute is different from legacy implied behaviour</h4>
    
    <p>
We touched on this in the weld subsystem example we used earlier in this guide, but let's take a more thorough look. Our comparison tells us that we have two new attributes <tt class=" ">require-bean-descriptor</tt> and <tt class=" ">non-portable-mode</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">====== Resource root address: [&quot;subsystem&quot; =&gt; &quot;weld&quot;] - Current version: 2.0.0; legacy version: 1.0.0 =======
--- Problems for relative address to root []:
Missing attributes in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]
Missing parameters for operation 'add' in current: []; missing in legacy [require-bean-descriptor, non-portable-mode]</pre>
        </div>
    </div>
    <p>
Now when we look at this we see that the default value for both of the attributes in the current model is <tt class=" ">false</tt>, which allows us more flexible behaviour introduced in CDI 1.1 (which was introduced with this version of the subsystem). The old model does not have these attributes, and implements CDI 1.0, which under the hood (using our weld subsystem expertise knowledge) implies the values <tt class=" ">true</tt> for both of these. So our transformer must reject anything that is not <tt class=" ">true</tt> for these attributes. Let us look at the transformer registered by the WeldExtension:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    private void registerTransformers(SubsystemRegistration subsystem) {
        ResourceTransformationDescriptionBuilder builder = TransformationDescriptionBuilder.Factory.createSubsystemInstance();
        //These new attributes are assumed to be 'true' in the old version but default to false in the current version. So discard if 'true' and reject if 'undefined'.
        builder.getAttributeBuilder()
                .setDiscard(new DiscardAttributeChecker.DiscardAttributeValueChecker(false, false, new ModelNode(true)),
                        WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .addRejectCheck(new RejectAttributeChecker.DefaultRejectAttributeChecker() {

                    @Override
                    public String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes) {
                        return WeldMessages.MESSAGES.rejectAttributesMustBeTrue(attributes.keySet());
                    }

                    @Override
                    protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue,
                            TransformationContext context) {
                        //This will not get called if it was discarded, so reject if it is undefined (default==false) or if defined and != 'true'
                        return !attributeValue.isDefined() || !attributeValue.asString().equals(&quot;true&quot;);
                    }
                }, WeldResourceDefinition.NON_PORTABLE_MODE_ATTRIBUTE, WeldResourceDefinition.REQUIRE_BEAN_DESCRIPTOR_ATTRIBUTE)
                .end();
        TransformationDescription.Tools.register(builder.build(), subsystem, ModelVersion.create(1, 0, 0));
    }</pre>
        </div>
    </div>
    <p>
This looks a bit more scary than the previous transformer we have seen, but isn't actually too bad. The first thing we do is register a <tt class=" ">DiscardAttributeChecker.DiscardAttributeValueChecker</tt> which will discard the attribute if it has the value <tt class=" ">true</tt>. It will not discard if it is <tt class=" ">undefined</tt> since that defaults to <tt class=" ">false</tt>. This is registered for both attributes.    </p>
    <p>
If the attributes had the value <tt class=" ">true</tt> they will get discarded we will not hit the reject checker since discarded attributes never get checked for rejection. If on the other hand they were an expression (since we are interested in the actual value, but cannot evaluate what value an expression will resolve to on the target from the DC running the transformers), <tt class=" ">false</tt>, or <tt class=" ">undefined</tt> (which will then default to <tt class=" ">false</tt>) they will not get discarded and will need to be rejected. So our <tt class=" ">RejectAttributeChecker.DefaultRejectAttributeChecker.rejectAttribute()</tt> method will return <tt class=" ">true</tt> (i.e. reject) if the attribute value is <tt class=" ">undefined</tt> (since that defaults to <tt class=" ">false</tt>) or if it is defined and 'not equal to <tt class=" ">true</tt>'. It is better to check for 'not equal to <tt class=" ">true</tt>' than to check for 'equal to <tt class=" ">false</tt>' since if an expression was used we still want to reject, and only the 'not equal to <tt class=" ">true</tt>' check would actually kick in in that case.    </p>
    <p>
The other thing we need in our <tt class=" ">DiscardAttributeChecker.DiscardAttributeValueChecker</tt> is to override the <tt class=" ">getRejectionLogMessage()</tt> method to get the message to be displayed when rejecting the transformation. In this case it says something along the lines &quot;These attributes must be 'true' for use with CDI 1.0 '%s'&quot;, with the names of the attributes having been rejected substituting the <tt class=" ">%s</tt>.    </p>
    </div>
    
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Attributehasadifferentdefaultvalue"  >
        <h3>Attribute has a different default value</h3>
    
    <p>
&ndash; TODO    </p>
    </div>
    
    <div class="section-3"  id="80873455_DomainModeSubsystemTransformers-Attributehasadifferenttype"  >
        <h3>Attribute has a different type</h3>
    
    <p>
Here the example comes from the <tt class=" ">capacity</tt> parameter some way into the <tt class=" ">modcluster</tt> subsystem, and the legacy version is AS 7.1.2.Final. There are quite a few differences, so I am only showing the ones relevant for this example:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">====== Resource root address: [&quot;subsystem&quot; =&gt; &quot;modcluster&quot;] - Current version: 2.0.0; legacy version: 1.2.0 =======
...
--- Problems for relative address to root [&quot;mod-cluster-config&quot; =&gt; &quot;configuration&quot;,&quot;dynamic-load-provider&quot; =&gt; &quot;configuration&quot;,&quot;custom-load-m
etric&quot; =&gt; &quot;*&quot;]:
Different 'type' for attribute 'capacity'. Current: DOUBLE; legacy: INT
Different 'expressions-allowed' for attribute 'capacity'. Current: true; legacy: false
...
Different 'type' for parameter 'capacity' of operation 'add'. Current: DOUBLE; legacy: INT
Different 'expressions-allowed' for parameter 'capacity' of operation 'add'. Current: true; legacy: false</pre>
        </div>
    </div>
    <p>
So as we can see expressions are not allowed for the <tt class=" ">capacity</tt> attribute, and the current type is <tt class=" ">double</tt> while the legacy subsystem is <tt class=" ">int</tt>. So this means that if the value is for example <tt class=" ">2.0</tt> we can convert this to <tt class=" ">2</tt>, but <tt class=" ">2.5</tt> cannot be converted. The way this is solved in the ModClusterExtension is to register the following some other attributes are registered here, but hopefully it is clear anyway:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">        dynamicLoadProvider.addChildResource(LOAD_METRIC_PATH)
                    .getAttributeBuilder()
                        .addRejectCheck(RejectAttributeChecker.SIMPLE_EXPRESSIONS, TYPE, WEIGHT, CAPACITY, PROPERTY)
                        .addRejectCheck(CapacityCheckerAndConverter.INSTANCE, CAPACITY)
                        .setValueConverter(CapacityCheckerAndConverter.INSTANCE, CAPACITY)
                        ...
                        .end();</pre>
        </div>
    </div>
    <p>
So we register that we should reject expressions, and we also register the <tt class=" ">CapacityCheckerAndConverter</tt> for <tt class=" ">capacity</tt>. <tt class=" ">CapacityCheckerAndConverter</tt> extends the convenience class <tt class=" ">DefaultCheckersAndConverter</tt> which implements the <tt class=" ">DiscardAttributeChecker</tt>, <tt class=" ">RejectAttributeChecker</tt>, and <tt class=" ">AttributeConverter</tt> interfaces. We have seen <tt class=" ">DiscardAttributeChecker</tt> and <tt class=" ">RejectAttributeChecker</tt> in previous examples. Since we now need to convert a value we need an instance of <tt class=" ">AttributeConverter</tt>.    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">    static class CapacityCheckerAndConverter extends DefaultCheckersAndConverter {

        static final CapacityCheckerAndConverter INSTANCE = new CapacityCheckerAndConverter();</pre>
        </div>
    </div>
    <p>
We should not discard so <tt class=" ">isValueDiscardable()</tt> from <tt class=" ">DiscardAttributeChecker</tt> always returns <tt class=" ">false</tt>:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">        @Override
        protected boolean isValueDiscardable(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {
            //Not used for discard
            return false;
        }

        @Override
        public String getRejectionLogMessage(Map&lt;String, ModelNode&gt; attributes) {
            return ModClusterMessages.MESSAGES.capacityIsExpressionOrGreaterThanIntegerMaxValue(attributes.get(CAPACITY.getName()));
        }</pre>
        </div>
    </div>
    <p>
Now we check to see if we can convert the attribute to an <tt class=" ">int</tt> and reject if not. Note that if it is an expression, we have no idea what its value will resolve to on the target host, so we need to reject it. Then we try to change it into an <tt class=" ">int</tt>, and reject if that was not possible:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">        @Override
        protected boolean rejectAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {
            if (checkForExpression(attributeValue)
                    || (attributeValue.isDefined() &amp;&amp; !isIntegerValue(attributeValue.asDouble()))) {
                return true;
            }
            Long converted = convert(attributeValue);
            return (converted != null &amp;&amp; (converted &gt; Integer.MAX_VALUE || converted &lt; Integer.MIN_VALUE));
        }</pre>
        </div>
    </div>
    <p>
And then finally we do the conversion:    </p>
    <div class="confbox programlisting">
                <div class="content">
        <pre class="brush: java; gutter: false;">        @Override
        protected void convertAttribute(PathAddress address, String attributeName, ModelNode attributeValue, TransformationContext context) {
            Long converted = convert(attributeValue);
            if (converted != null &amp;&amp; converted &lt;= Integer.MAX_VALUE &amp;&amp; converted &gt;= Integer.MIN_VALUE) {
                attributeValue.set((int)converted.longValue());
            }
        }


        private Long convert(ModelNode attributeValue) {
            if (attributeValue.isDefined() &amp;&amp; !checkForExpression(attributeValue)) {
                double raw = attributeValue.asDouble();
                if (isIntegerValue(raw)) {
                    return Math.round(raw);
                }
            }
            return null;
        }

        private boolean isIntegerValue(double raw) {
            return raw == Double.valueOf(Math.round(raw)).doubleValue();
        }

    }</pre>
        </div>
    </div>
    </div>
    
    </div>
    
        </div>
              <ul class="docnav">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <li class="previous"><a accesskey="p" href="Extending_WildFly.html"><strong>Prev</strong>Extending WildFly</a></li>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li>
          <li class="home"><a accesskey="h" href="Documentation.html"><strong>Front page</strong></a></li>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <li class="next"><a accesskey="n" href="Example_subsystem.html"><strong>Next</strong>Example subsystem</a></li>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </ul>
          </div>
    <script type="text/javascript">
      SyntaxHighlighter.all()
    </script>
</body>
</html>
